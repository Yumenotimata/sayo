/* Parser combinators
*/
module interface std/text/parse
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/core/undiv = std/core/undiv = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 

// Operations:
// ```koka
// fun satisfy
// ctl fail
// ctl pick
// fun current-input
// ```
pub recursive effect type parse[17,1,17,16] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-parse[17,1,17,16](@cfc: std/core/types/int, @fun-current-input: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, @ctl-fail: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>, @ctl-pick: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, @fun-satisfy: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>){0,5,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>) -> (parse :: (E, V) -> V)<(e :: E),a>;
};
pub type parse-error[29,1,31,43] <a> :: V -> V {
  pub con ParseOk[30,3,30,9](result: a, rest: std/core/sslice/sslice){0,4,8} : forall<a> (result : a, rest : std/core/sslice/sslice) -> (parse-error :: V -> V)<a>;
  pub con ParseError[31,3,31,12](msg: std/core/types/string, rest: std/core/sslice/sslice){0,4,8} : forall<a> (msg : std/core/types/string, rest : std/core/sslice/sslice) -> (parse-error :: V -> V)<a>;
};
pub alias parser[15,1,15,41]<(e :: E),a> :: (E, V) -> V = () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a = 1;
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:parse` type.
 fun parse/@cfc[17,1,17,16] : forall<(e :: E),a> (^ parse : (parse :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-current-input` constructor field of the `:parse` type.
 fun parse/@fun-current-input[21,7,21,30] : forall<(e :: E),a> (^ parse : (parse :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@ctl-fail` constructor field of the `:parse` type.
 fun parse/@ctl-fail[19,7,19,28] : forall<(e :: E),a,b> (^ parse : (parse :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@ctl-pick` constructor field of the `:parse` type.
 fun parse/@ctl-pick[20,7,20,19] : forall<(e :: E),a> (^ parse : (parse :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-satisfy` constructor field of the `:parse` type.
 fun parse/@fun-satisfy[18,7,18,68] : forall<(e :: E),a,b> (^ parse : (parse :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `rest` constructor field of the `:parse-error` type.
pub  fun parse-error/rest[30,23,30,26] : forall<a> (^ @this : (parse-error :: V -> V)<a>) -> std/core/sslice/sslice;
// Automatically generated. Tests for the `ParseOk` constructor of the `:parse-error` type.
pub fip fun is-parseOk[30,3,30,9] : forall<a> (^ parse-error : (parse-error :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `ParseError` constructor of the `:parse-error` type.
pub fip fun is-parseError[31,3,31,12] : forall<a> (^ parse-error : (parse-error :: V -> V)<a>) -> std/core/types/bool;
// runtime tag for the effect `:parse`
pub val @tag-parse[17,1,17,16] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>;
// handler for the effect `:parse`
pub  fun @handle-parse[17,12,17,16] : forall<a,(e :: E),b> (hnd : (parse :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `satisfy` operation out of effect `:parse`
pub  fun @select-satisfy[18,7,18,68] : forall<a,(e :: E),b> (^ hnd : (parse :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<a>,(parse :: (E, V) -> V),(e :: E),b>;
// Call the `fun satisfy` operation of the effect `:parse`
pub  fun satisfy[18,7,18,13] : forall<a> (pred : (std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/types/maybe :: V -> V)<a>;
// select `fail` operation out of effect `:parse`
pub  fun @select-fail[19,7,19,28] : forall<a,(e :: E),b> (^ hnd : (parse :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,a,(parse :: (E, V) -> V),(e :: E),b>;
// Call the `ctl fail` operation of the effect `:parse`
pub  fun fail[19,7,19,10] : forall<a> (msg : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> a;
// select `pick` operation out of effect `:parse`
pub  fun @select-pick[20,7,20,19] : forall<(e :: E),a> (^ hnd : (parse :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>;
// Call the `ctl pick` operation of the effect `:parse`
pub  fun pick[20,7,20,10] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/bool;
// select `current-input` operation out of effect `:parse`
pub  fun @select-current-input[21,7,21,30] : forall<(e :: E),a> (^ hnd : (parse :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>;
// Call the `fun current-input` operation of the effect `:parse`
pub  fun current-input[21,7,21,19] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/sslice/sslice;
pub  fun either[36,9,36,14] : forall<a> (perr : (parse-error :: V -> V)<a>) -> (std/core/types/either :: (V, V) -> V)<std/core/types/string,a>;
pub  fun maybe[33,9,33,13] : forall<a> (perr : (parse-error :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10532[1,0,1,0] : forall<(h :: H),a,(e :: E)> (msg : std/core/types/string, @y-x10366 : std/core/sslice/sslice) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10533[1,0,1,0] : forall<(h :: H),a,(e :: E)> (err1 : (parse-error :: V -> V)<a>, @y-x10370 : (parse-error :: V -> V)<a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10534[1,0,1,0] : forall<(h :: H),a,(e :: E)> (err1 : (parse-error :: V -> V)<a>, resume : (std/core/types/bool) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10535[1,0,1,0] : forall<(h :: H),a,(e :: E)> (input : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/sslice/sslice>, resume : (std/core/types/bool) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>, save : std/core/sslice/sslice, @y-x10368 : (parse-error :: V -> V)<a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10536[1,0,1,0] : forall<(h :: H),a,(e :: E)> (input : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/sslice/sslice>, resume : (std/core/types/bool) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>, save : std/core/sslice/sslice) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10537[1,0,1,0] : forall<a,(h :: H),(e :: E)> (x : a, wild_@0 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (std/core/types/maybe :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10538[1,0,1,0] : forall<a,(h :: H),(e :: E)> (input : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/sslice/sslice>, pred : (std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>, inp : std/core/sslice/sslice) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (std/core/types/maybe :: V -> V)<a>;
// monadic lift
 fun @mlift-parse@10539[1,0,1,0] : forall<(h :: H),a,(e :: E)> (x@0 : a, @y-x10375 : std/core/sslice/sslice) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (parse-error :: V -> V)<a>;
pub  fun parse[47,9,47,13] : forall<a,(e :: E)> (input0 : std/core/sslice/sslice, p : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) (parse-error :: V -> V)<a>;
pub  fun starts-with[23,9,23,19] : forall<a> (s : std/core/types/string, p : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> a) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>;
// monadic lift
 fun (@mlift-x@10540||)[1,0,1,0] : forall<a,(e :: E)> (p1 : (parser :: (E, V) -> V)<(e :: E),a>, p2 : (parser :: (E, V) -> V)<(e :: E),a>, @y-x10381 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
pub  fun (||)[77,9,77,12] : forall<a,(e :: E)> (p1 : (parser :: (E, V) -> V)<(e :: E),a>, p2 : (parser :: (E, V) -> V)<(e :: E),a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
// monadic lift
 fun @mlift-optional@10541[1,0,1,0] : forall<a,(e :: E)> (default : a, p : (parser :: (E, V) -> V)<(e :: E),a>, @y-x10386 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
pub  fun optional[80,9,80,16] : forall<a,(e :: E)> (default : a, p : (parser :: (E, V) -> V)<(e :: E),a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
// monadic lift
 fun @mlift-unroll-choose@10000@10542[1,0,1,0] : forall<a,(e :: E)> (p@0 : (parser :: (E, V) -> V)<(e :: E),a>, pp : (std/core/types/list :: V -> V)<(parser :: (E, V) -> V)<(e :: E),a>>, @y-x10393 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
 fun @unroll-choose@10000[83,9,83,14] : forall<a,(e :: E)> (ps : (std/core/types/list :: V -> V)<(parser :: (E, V) -> V)<(e :: E),a>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
// unrolling of singleton matches of std/text/parse/@unroll-choose@10000
pub  fun choose[83,9,83,14] : forall<a,(e :: E)> (ps : (std/core/types/list :: V -> V)<(parser :: (E, V) -> V)<(e :: E),a>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
// monadic lift
 fun @mlift-satisfy-fail@10543[1,0,1,0] : forall<a> (msg : std/core/types/string, @y-x10402 : (std/core/types/maybe :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> a;
pub  fun satisfy-fail[89,9,89,20] : forall<a> (msg : std/core/types/string, pred : (std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> a;
// monadic lift
 fun @mlift-eof@10544[1,0,1,0] : (@y-x10405 : (std/core/types/maybe :: V -> V)<()>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> ();
pub  fun eof[94,9,94,11] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-parse-eof@10545[1,0,1,0] : (@y-x10409 : (std/core/types/maybe :: V -> V)<()>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> ();
// monadic lift
 fun @mlift-parse-eof@10546[1,0,1,0] : forall<a,(e :: E)> (x : a, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
// monadic lift
 fun @mlift-parse-eof@10547[1,0,1,0] : forall<a,(e :: E)> (x : a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a;
pub  fun parse-eof[41,9,41,17] : forall<a,(e :: E)> (input : std/core/sslice/sslice, p : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) (parse-error :: V -> V)<a>;
// monadic lift
 fun @mlift-char-is@10548[1,0,1,0] : (msg : std/core/types/string, @y-x10414 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun char-is[99,9,99,15] : (msg : std/core/types/string, pred : (std/core/types/char) -> std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
 fun next-while0[106,5,106,15] : (slice : std/core/sslice/sslice, pred : (std/core/types/char) -> std/core/types/bool, acc : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-chars-are@10549[1,0,1,0] : (msg : std/core/types/string, @y-x10417 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/types/list :: V -> V)<std/core/types/char>;
pub  fun chars-are[112,9,112,17] : (msg : std/core/types/string, pred : (std/core/types/char) -> std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/types/list :: V -> V)<std/core/types/char>;
 fun @unroll-next-match@10001[118,5,118,14] : (slice : std/core/sslice/sslice, cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> (std/core/types/maybe :: V -> V)<std/core/sslice/sslice>;
// unrolling of singleton matches of std/text/parse/@unroll-next-match@10001
 fun next-match[118,5,118,14] : (slice : std/core/sslice/sslice, cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> (std/core/types/maybe :: V -> V)<std/core/sslice/sslice>;
// monadic lift
 fun @mlift-pstring@10550[1,0,1,0] : (s : std/core/types/string, @y-x10420 : (std/core/types/maybe :: V -> V)<std/core/types/string>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
pub  fun pstring[125,9,125,15] : (s : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// monadic lift
 fun @mlift-char@10551[1,0,1,0] : (msg@10031 : std/core/types/string, @y-x10423 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun char[131,9,131,12] : (c : std/core/types/char) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-no-digit@10552[1,0,1,0] : (@y-x10426 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun no-digit[134,9,134,16] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-digit@10553[1,0,1,0] : (@c-x10431 : std/core/types/char) -> std/core/types/int;
// monadic lift
 fun @mlift-digit@10554[1,0,1,0] : (@y-x10429 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/int;
pub  fun digit[137,9,137,13] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-alpha@10555[1,0,1,0] : (@y-x10432 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun alpha[141,9,141,13] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-alpha-num@10556[1,0,1,0] : (@y-x10435 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun alpha-num[144,9,144,17] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-white@10557[1,0,1,0] : (@y-x10438 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun white[147,9,147,13] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// lifted local: whitespace, @spec-x10269
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10260, using:
// @uniq-pred@10260 = std/core/char/is-white
 fun @lift-whitespace@10348[1,0,1,0] : (@uniq-slice@10259 : std/core/sslice/sslice, @uniq-acc@10261 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-whitespace@10558[1,0,1,0] : (@y-x10441 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
pub  fun whitespace[150,9,150,18] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// lifted local: whitespace0, @spec-x10280
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10271, using:
// @uniq-pred@10271 = std/core/char/is-white
 fun @lift-whitespace0@10349[1,0,1,0] : (@uniq-slice@10270 : std/core/sslice/sslice, @uniq-acc@10272 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-whitespace0@10559[1,0,1,0] : (@y-x10445 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// monadic lift
 fun @mlift-whitespace0@10560[1,0,1,0] : (@y-x10444 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
pub  fun whitespace0[153,9,153,19] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// lifted local: digits, @spec-x10291
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10282, using:
// @uniq-pred@10282 = std/core/char/is-digit
 fun @lift-digits@10350[1,0,1,0] : (@uniq-slice@10281 : std/core/sslice/sslice, @uniq-acc@10283 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-digits@10561[1,0,1,0] : (@y-x10449 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
pub  fun digits[156,9,156,14] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// lifted local: digits0, @spec-x10302
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10293, using:
// @uniq-pred@10293 = std/core/char/is-digit
 fun @lift-digits0@10351[1,0,1,0] : (@uniq-slice@10292 : std/core/sslice/sslice, @uniq-acc@10294 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-digits0@10562[1,0,1,0] : (@y-x10453 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// monadic lift
 fun @mlift-digits0@10563[1,0,1,0] : (@y-x10452 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
pub  fun digits0[159,9,159,15] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// lifted local: pnat, @spec-x10313
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10304, using:
// @uniq-pred@10304 = std/core/char/is-digit
 fun @lift-pnat@10352[1,0,1,0] : (@uniq-slice@10303 : std/core/sslice/sslice, @uniq-acc@10305 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-pnat@10564[1,0,1,0] : (@c-x10459 : (std/core/types/list :: V -> V)<std/core/types/char>) -> std/core/types/int;
// monadic lift
 fun @mlift-pnat@10565[1,0,1,0] : (@y-x10457 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/int;
pub  fun pnat[166,9,166,12] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-none-of@10566[1,0,1,0] : (@y-x10460 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun none-of[174,9,174,15] : (chars : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// lifted local: none-of-many1, @spec-x10324
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10315, using:
// @uniq-pred@10315 = fn(c: char){
//   val b@10116 : bool
//         = std/core/string/contains(chars, (std/core/string/char/string(c)));
//   match (b@10116) {
//     ((std/core/types/True() : bool ) as @pat@9: bool)
//        -> std/core/types/False;
//     ((@skip std/core/types/False() : bool ) as @pat@0@1: bool)
//        -> std/core/types/True;
//   };
// }
 fun @lift-none-of-many1@10353[1,0,1,0] : (chars : std/core/types/string, @uniq-slice@10314 : std/core/sslice/sslice, @uniq-acc@10316 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-none-of-many1@10567[1,0,1,0] : (@y-x10463 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
pub  fun none-of-many1[177,9,177,21] : (chars : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
// monadic lift
 fun @mlift-one-of@10568[1,0,1,0] : (chars : std/core/types/string, @y-x10466 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun one-of[180,9,180,14] : (chars : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-many-acc@10569[1,0,1,0] : forall<a,(e :: E)> (acc : (std/core/types/list :: V -> V)<a>, p : (parser :: (E, V) -> V)<(e :: E),a>, x : a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-many-acc@10570[1,0,1,0] : forall<a,(e :: E)> (acc : (std/core/types/list :: V -> V)<a>, p : (parser :: (E, V) -> V)<(e :: E),a>, @y-x10470 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
 fun many-acc[184,5,184,12] : forall<a,(e :: E)> (p : (parser :: (E, V) -> V)<(e :: E),a>, acc : (std/core/types/list :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
// The `many` combinator parses `p` until it fails, returning a list of the results of `p`.
// The `many` combinator is non-divergent only when `p` always consumes input or `fail`s.
pub  fun many[189,9,189,12] : forall<a,(e :: E)> (p : (parser :: (E, V) -> V)<(e :: E),a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-many1@10571[1,0,1,0] : forall<a,(e :: E)> (@y-x10475 : a, @y-x10476 : (std/core/types/list :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-many1@10572[1,0,1,0] : forall<a,(e :: E)> (p : (parser :: (E, V) -> V)<(e :: E),a>, @y-x10475 : a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
// The `many1` combinator parses `p` at least once an then until it fails, returning a list of the results of `p`.
// The `many1` combinator is non-divergent only when `p` always consumes input or `fail`s.
pub  fun many1[194,9,194,13] : forall<a,(e :: E)> (p : (parser :: (E, V) -> V)<(e :: E),a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-count-acc@10573[1,0,1,0] : forall<a,(e :: E)> (acc : (std/core/types/list :: V -> V)<a>, n : std/core/types/int, p : (parser :: (E, V) -> V)<(e :: E),a>, x : a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
 fun count-acc[197,5,197,13] : forall<a,(e :: E)> (n : std/core/types/int, acc : (std/core/types/list :: V -> V)<a>, p : (parser :: (E, V) -> V)<(e :: E),a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
pub  fun count[203,9,203,13] : forall<a,(e :: E)> (n : std/core/types/int, p : (parser :: (E, V) -> V)<(e :: E),a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-one-of-or@10574[1,0,1,0] : (chars : std/core/types/string, default : std/core/types/char, @y-x10481 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
pub  fun one-of-or[206,9,206,17] : (chars : std/core/types/string, default : std/core/types/char) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-sign@10575[1,0,1,0] : (@y-x10485 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-sign@10576[1,0,1,0] : (@c-x10488 : std/core/types/char) -> std/core/types/bool;
// monadic lift
 fun @mlift-sign@10577[1,0,1,0] : (@y-x10484 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/bool;
pub  fun sign[162,9,162,12] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/bool;
// lifted local: i, pint, @spec-x10336
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10327, using:
// @uniq-pred@10327 = std/core/char/is-digit
 fun @lift-pint@10354[1,0,1,0] : (@uniq-slice@10326 : std/core/sslice/sslice, @uniq-acc@10328 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-pint@10578[1,0,1,0] : (neg : std/core/types/bool, @c-x10496 : (std/core/types/list :: V -> V)<std/core/types/char>) -> std/core/types/int;
// monadic lift
 fun @mlift-pint@10579[1,0,1,0] : (neg : std/core/types/bool, @y-x10494 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/int;
// monadic lift
 fun @mlift-pint@10580[1,0,1,0] : (@y-x10490 : (std/core/types/maybe :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/char;
// monadic lift
 fun @mlift-pint@10581[1,0,1,0] : (@c-x10493 : std/core/types/char) -> std/core/types/int;
// monadic lift
 fun @mlift-pint@10582[1,0,1,0] : (@y-x10489 : std/core/types/bool) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/int;
pub  fun pint[169,9,169,12] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/int;
// lifted local: hex-digits, @spec-x10347
// specialized: std/text/parse/next-while0, on parameters @uniq-pred@10338, using:
// @uniq-pred@10338 = std/core/char/is-hex-digit
 fun @lift-hex-digits@10355[1,0,1,0] : (@uniq-slice@10337 : std/core/sslice/sslice, @uniq-acc@10339 : (std/core/types/list :: V -> V)<std/core/types/char>) -> ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice);
// monadic lift
 fun @mlift-hex-digits@10583[1,0,1,0] : (@y-x10498 : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
pub  fun hex-digits[212,9,212,18] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "_*"  fun chars-are // inline size: 1
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(msg: std/core/types/string, pred: (std/core/types/char) -> std/core/types/bool){
    match ((std/core/hnd/@perform1<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),a> std/text/parse/@select-satisfy<(std/core/types/list :: V -> V)<std/core/types/char>,(e :: E),a>), (fn(slice: std/core/sslice/sslice){
        (match ((std/text/parse/next-while0(slice, pred, (std/core/types/Nil<std/core/types/char>)))) {
          ((@skip std/core/types/Tuple2(((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/char> ) as @pat@0@0: (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/list :: V -> V)<std/core/types/char>, ((@skip std/core/sslice/Sslice((@pat@2: std/core/types/string) : std/core/types/string, (@pat@3: std/core/types/int) : std/core/types/int, (@pat@4: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@1@0: std/core/sslice/sslice) : std/core/sslice/sslice) : ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice) ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice))
             -> std/core/types/Nothing<((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice)>;
          ((@skip std/core/types/Tuple2((xs: (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/list :: V -> V)<std/core/types/char>, ((@skip std/core/sslice/Sslice((@pat@6: std/core/types/string) : std/core/types/string, (@pat@7: std/core/types/int) : std/core/types/int, (@pat@8: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as rest: std/core/sslice/sslice) : std/core/sslice/sslice) : ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice) ) as @pat@5: ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice))
             -> std/core/types/Just<((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice)>((std/core/types/Tuple2<(std/core/types/list :: V -> V)<std/core/types/char>,std/core/sslice/sslice>(xs, rest)));
        });
      })))) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>> ) as @pat: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>))
         -> std/core/hnd/@perform1<std/core/types/string,(std/core/types/list :: V -> V)<std/core/types/char>,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),a> std/text/parse/@select-fail<(std/core/types/list :: V -> V)<std/core/types/char>,(e :: E),a>), msg);
      ((@skip std/core/types/Just((x: (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>> ) as @pat@0: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>))
         -> x;
    };
  };
specialize "_*"  fun count // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(n: std/core/types/int, p: (parser :: (E, V) -> V)<(e :: E),a>){
    std/text/parse/count-acc<a,(e :: E)>(n, (std/core/types/Nil<a>), p);
  };
recursive specialize "__*"  fun count-acc // inline size: 15
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(n: std/core/types/int, acc: (std/core/types/list :: V -> V)<a>, p: (parser :: (E, V) -> V)<(e :: E),a>){
    (match ((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> std/core/types/bool>(std/core/int/(<=))(n, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>,(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>>((fn(xs: (std/core/types/list :: V -> V)<a>){
          (match (xs) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
               -> std/core/types/Nil<a>;
            (@pat@1: ((std/core/types/list :: V -> V)<a>))
               -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs);
          });
        }))(acc);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@0: std/core/types/bool)
         -> val x[199,9,199,9] : a
                  = p();
        std/text/parse/count-acc<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>,(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> std/core/types/int>((std/core/undiv/pretend-decreasing<std/core/types/int>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> std/core/types/int>((fn(x@0: std/core/types/int, y: std/core/types/int){
            (std/core/int/int-sub(x@0, y));
          }))(n, 1)))), (std/core/types/Cons<a>(x, acc)), p);
    });
  };
recursive specialize "_*_"  fun next-while0 // inline size: 9
  = fn(slice: std/core/sslice/sslice, pred: (std/core/types/char) -> std/core/types/bool, acc: (std/core/types/list :: V -> V)<std/core/types/char>){
    match ((std/core/sslice/next(slice))) {
      ((std/core/types/Just(((std/core/types/Tuple2((c: std/core/types/char) : std/core/types/char, (rest: std/core/sslice/sslice) : std/core/sslice/sslice) : (std/core/types/char, std/core/sslice/sslice) ) as @pat@0: (std/core/types/char, std/core/sslice/sslice)) : (std/core/types/char, std/core/sslice/sslice)) : (std/core/types/maybe :: V -> V)<(std/core/types/char, std/core/sslice/sslice)> ) as @pat: ((std/core/types/maybe :: V -> V)<(std/core/types/char, std/core/sslice/sslice)>))
         | pred(c) -> std/text/parse/next-while0((std/core/undiv/pretend-decreasing<std/core/sslice/sslice>(rest)), pred, (std/core/types/Cons<std/core/types/char>(c, acc)));
      (@pat@1: ((std/core/types/maybe :: V -> V)<(std/core/types/char, std/core/sslice/sslice)>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<std/core/types/char>,std/core/sslice/sslice>((match (acc) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/char> ) as @pat@0@0: ((std/core/types/list :: V -> V)<std/core/types/char>))
               -> std/core/types/Nil<std/core/types/char>;
            (@pat@2: ((std/core/types/list :: V -> V)<std/core/types/char>))
               -> std/core/list/@unroll-lift-reverse-append@4948@10003<std/core/types/char>((std/core/types/Nil<std/core/types/char>), acc);
          }), slice);
    };
  };
specialize "*"  fun none-of-many1 // inline size: 1
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(chars: std/core/types/string){
    std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> std/core/types/string,(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/string>(std/core/string/#listchar/string)((match ((std/core/hnd/@perform1<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),a> std/text/parse/@select-satisfy<(std/core/types/list :: V -> V)<std/core/types/char>,(e :: E),a>), (fn(slice: std/core/sslice/sslice){
        (match ((std/text/parse/next-while0(slice, (fn(c: std/core/types/char){
            val b@10116[1,0,1,0] : std/core/types/bool
                  = (std/core/string/contains(chars, (std/core/string/#char/string(c))));
            (match (b@10116) {
              ((std/core/types/True() : std/core/types/bool ) as @pat@9: std/core/types/bool)
                 -> std/core/types/False;
              ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@1: std/core/types/bool)
                 -> std/core/types/True;
            });
          }), (std/core/types/Nil<std/core/types/char>)))) {
          ((@skip std/core/types/Tuple2(((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/char> ) as @pat@0@0: (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/list :: V -> V)<std/core/types/char>, ((@skip std/core/sslice/Sslice((@pat@2: std/core/types/string) : std/core/types/string, (@pat@3: std/core/types/int) : std/core/types/int, (@pat@4: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@1@0: std/core/sslice/sslice) : std/core/sslice/sslice) : ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice) ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice))
             -> std/core/types/Nothing<((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice)>;
          ((@skip std/core/types/Tuple2((xs: (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/list :: V -> V)<std/core/types/char>, ((@skip std/core/sslice/Sslice((@pat@6: std/core/types/string) : std/core/types/string, (@pat@7: std/core/types/int) : std/core/types/int, (@pat@8: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as rest: std/core/sslice/sslice) : std/core/sslice/sslice) : ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice) ) as @pat@5: ((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice))
             -> std/core/types/Just<((std/core/types/list :: V -> V)<std/core/types/char>, std/core/sslice/sslice)>((std/core/types/Tuple2<(std/core/types/list :: V -> V)<std/core/types/char>,std/core/sslice/sslice>(xs, rest)));
        });
      })))) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>> ) as @pat: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>))
         -> std/core/hnd/@perform1<std/core/types/string,(std/core/types/list :: V -> V)<std/core/types/char>,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),a> std/text/parse/@select-fail<(std/core/types/list :: V -> V)<std/core/types/char>,(e :: E),a>), "");
      ((@skip std/core/types/Just((x: (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/list :: V -> V)<std/core/types/char>) : (std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>> ) as @pat@0: ((std/core/types/maybe :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>))
         -> x;
    }));
  };
inline borrow "^"  fun parse/@cfc // inline size: 0
  = forall<(e :: E),a> fn(parse@0: (parse :: (E, V) -> V)<(e :: E),a>){
    (match (parse@0) {
      ((@skip std/text/parse/@Hnd-parse((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, (@pat@1: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>) : forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, (@pat@3: (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (parse :: (E, V) -> V)<(e :: E),a> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun parse/@fun-current-input // inline size: 0
  = forall<(e :: E),a> fn(parse@0: (parse :: (E, V) -> V)<(e :: E),a>){
    (match (parse@0) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, (@pat@1: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>) : forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, (@pat@3: (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (parse :: (E, V) -> V)<(e :: E),a> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun parse/@ctl-fail // inline size: 0
  = forall<(e :: E),a,b> fn(parse@0: (parse :: (E, V) -> V)<(e :: E),a>){
    (match (parse@0) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, (@x: forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),a>) : forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, (@pat@3: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),a>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),a>)) : (parse :: (E, V) -> V)<(e :: E),a> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),a>))
         -> @x<b>;
    });
  };
inline borrow "^"  fun parse/@ctl-pick // inline size: 0
  = forall<(e :: E),a> fn(parse@0: (parse :: (E, V) -> V)<(e :: E),a>){
    (match (parse@0) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, (@pat@2: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>) : forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, (@pat@3: (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (parse :: (E, V) -> V)<(e :: E),a> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun parse/@fun-satisfy // inline size: 0
  = forall<(e :: E),a,b> fn(parse@0: (parse :: (E, V) -> V)<(e :: E),a>){
    (match (parse@0) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, (@pat@2: forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),a>) : forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),a>, (@pat@3: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, (@x: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),a>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),a>)) : (parse :: (E, V) -> V)<(e :: E),a> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),a>))
         -> @x<b>;
    });
  };
inline borrow "^"  fun parse-error/rest // inline size: 1
  = forall<a> fn(@this: (parse-error :: V -> V)<a>){
    (match (@this) {
      ((std/text/parse/ParseOk((@pat@0: a) : a, ((@skip std/core/sslice/Sslice((@pat@1: std/core/types/string) : std/core/types/string, (@pat@2: std/core/types/int) : std/core/types/int, (@pat@3: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @x: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat: ((parse-error :: V -> V)<a>))
         -> @x;
      ((@skip std/text/parse/ParseError((@pat@5: std/core/types/string) : std/core/types/string, ((@skip std/core/sslice/Sslice((@pat@6: std/core/types/string) : std/core/types/string, (@pat@7: std/core/types/int) : std/core/types/int, (@pat@8: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @x@0: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat@4: ((parse-error :: V -> V)<a>))
         -> @x@0;
    });
  };
inline borrow "^" fip fun is-parseOk // inline size: 1
  = forall<a> fn(parse-error: (parse-error :: V -> V)<a>){
    (match (parse-error) {
      ((std/text/parse/ParseOk((@pat@0: a) : a, ((@skip std/core/sslice/Sslice((@pat@2: std/core/types/string) : std/core/types/string, (@pat@3: std/core/types/int) : std/core/types/int, (@pat@4: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@1: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat: ((parse-error :: V -> V)<a>))
         -> std/core/types/True;
      (@pat@5: ((parse-error :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fip fun is-parseError // inline size: 1
  = forall<a> fn(parse-error: (parse-error :: V -> V)<a>){
    (match (parse-error) {
      ((std/text/parse/ParseError((@pat@0: std/core/types/string) : std/core/types/string, ((@skip std/core/sslice/Sslice((@pat@2: std/core/types/string) : std/core/types/string, (@pat@3: std/core/types/int) : std/core/types/int, (@pat@4: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@1: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat: ((parse-error :: V -> V)<a>))
         -> std/core/types/True;
      (@pat@5: ((parse-error :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^"  fun @select-satisfy // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (parse :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),b>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),b>, (@pat@2: forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),b>) : forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),b>, (@pat@3: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),b>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),b>, (@fun-satisfy: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),b>)) : (parse :: (E, V) -> V)<(e :: E),b> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),b>))
         -> @fun-satisfy<a>;
    });
  };
inline  fun satisfy // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(pred: (std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>){
    std/core/hnd/@perform1<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<a>,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> std/text/parse/@select-satisfy<a,(e :: E),b>), pred);
  };
inline borrow "^"  fun @select-fail // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (parse :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),b>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),b>, (@ctl-fail: forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),b>) : forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,c,(parse :: (E, V) -> V),(e :: E),b>, (@pat@2: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),b>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),b>, (@pat@3: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(c, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<c>,(parse :: (E, V) -> V),(e :: E),b>)) : (parse :: (E, V) -> V)<(e :: E),b> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),b>))
         -> @ctl-fail<a>;
    });
  };
inline  fun fail // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(msg: std/core/types/string){
    std/core/hnd/@perform1<std/core/types/string,a,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> std/text/parse/@select-fail<a,(e :: E),b>), msg);
  };
inline borrow "^"  fun @select-pick // inline size: 0
  = forall<(e :: E),a> fn(hnd: (parse :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, (@pat@2: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>) : forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>, (@ctl-pick: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, (@pat@3: (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (parse :: (E, V) -> V)<(e :: E),a> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),a>))
         -> @ctl-pick;
    });
  };
inline  fun pick // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<std/core/types/bool,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(parse :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), std/text/parse/@select-pick);
  };
inline borrow "^"  fun @select-current-input // inline size: 0
  = forall<(e :: E),a> fn(hnd: (parse :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip std/text/parse/@Hnd-parse((@pat@0: std/core/types/int) : std/core/types/int, (@fun-current-input: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/sslice/sslice,(parse :: (E, V) -> V),(e :: E),a>, (@pat@1: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>) : forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,b,(parse :: (E, V) -> V),(e :: E),a>, (@pat@2: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<std/core/types/bool,(parse :: (E, V) -> V),(e :: E),a>, (@pat@3: (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(b, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<b>,(parse :: (E, V) -> V),(e :: E),a>)) : (parse :: (E, V) -> V)<(e :: E),a> ) as @pat: ((parse :: (E, V) -> V)<(e :: E),a>))
         -> @fun-current-input;
    });
  };
inline  fun current-input // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<std/core/sslice/sslice,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(parse :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), std/text/parse/@select-current-input);
  };
 fun either // inline size: 3
  = forall<a> fn(perr: (parse-error :: V -> V)<a>){
    (match (perr) {
      ((std/text/parse/ParseOk((x: a) : a, ((@skip std/core/sslice/Sslice((@pat@1: std/core/types/string) : std/core/types/string, (@pat@2: std/core/types/int) : std/core/types/int, (@pat@3: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@0: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat: ((parse-error :: V -> V)<a>))
         -> std/core/types/Right<std/core/types/string,a>(x);
      ((@skip std/text/parse/ParseError((msg: std/core/types/string) : std/core/types/string, ((@skip std/core/sslice/Sslice((@pat@6: std/core/types/string) : std/core/types/string, (@pat@7: std/core/types/int) : std/core/types/int, (@pat@8: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@5: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat@4: ((parse-error :: V -> V)<a>))
         -> std/core/types/Left<std/core/types/string,a>(msg);
    });
  };
 fun maybe // inline size: 2
  = forall<a> fn(perr: (parse-error :: V -> V)<a>){
    (match (perr) {
      ((std/text/parse/ParseOk((x@0: a) : a, ((@skip std/core/sslice/Sslice((@pat@1@0: std/core/types/string) : std/core/types/string, (@pat@2@0: std/core/types/int) : std/core/types/int, (@pat@3: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@0@0: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat@2: ((parse-error :: V -> V)<a>))
         -> std/core/types/Just<a>(x@0);
      ((@skip std/text/parse/ParseError((msg: std/core/types/string) : std/core/types/string, ((@skip std/core/sslice/Sslice((@pat@6: std/core/types/string) : std/core/types/string, (@pat@7: std/core/types/int) : std/core/types/int, (@pat@8: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as @pat@5: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat@4: ((parse-error :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
    });
  };
 fun starts-with // inline size: 6
  = forall<a> fn(s: std/core/types/string, p: () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> a){
    (match ((std/text/parse/parse<a,(std/core/types/total :: E)>((std/core/sslice/Sslice(s, 0, (std/core/sslice/length(s)))), p))) {
      ((std/text/parse/ParseOk((x: a) : a, ((@skip std/core/sslice/Sslice((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: std/core/types/int) : std/core/types/int, (@pat@2: std/core/types/int) : std/core/types/int) : std/core/sslice/sslice ) as rest: std/core/sslice/sslice) : std/core/sslice/sslice) : (parse-error :: V -> V)<a> ) as @pat: ((parse-error :: V -> V)<a>))
         -> std/core/types/Just<(a, std/core/sslice/sslice)>((std/core/types/Tuple2<a,std/core/sslice/sslice>(x, rest)));
      (@pat@3: ((parse-error :: V -> V)<a>))
         -> std/core/types/Nothing<(a, std/core/sslice/sslice)>;
    });
  };
 fun (||) // inline size: 10
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(p1: (parser :: (E, V) -> V)<(e :: E),a>, p2: (parser :: (E, V) -> V)<(e :: E),a>){
    (match ((std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>,() -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/bool,() -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> std/core/types/bool>((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(){
      (std/core/hnd/@perform0<std/core/types/bool,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(parse :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), std/text/parse/@select-pick));
    }))())) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> p1();
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> p2();
    });
  };
 fun optional // inline size: 9
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(default: a, p: (parser :: (E, V) -> V)<(e :: E),a>){
    (match ((std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>,() -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/bool,() -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> std/core/types/bool>((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(){
      (std/core/hnd/@perform0<std/core/types/bool,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(parse :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), std/text/parse/@select-pick));
    }))())) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> p();
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> default;
    });
  };
inline  fun choose // inline size: 9
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(ps: (std/core/types/list :: V -> V)<(parser :: (E, V) -> V)<(e :: E),a>>){
    (match (ps) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(parser :: (E, V) -> V)<(e :: E),a>> ) as @pat: ((std/core/types/list :: V -> V)<(parser :: (E, V) -> V)<(e :: E),a>>))
         -> std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>,(msg : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> a,(msg : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)> a>((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(msg: std/core/types/string){
          (std/core/hnd/@perform1<std/core/types/string,a,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e1 :: E),b> std/text/parse/@select-fail<a,(e1 :: E),b>), msg));
        }))("no further alternatives");
      (@pat@0: ((std/core/types/list :: V -> V)<(parser :: (E, V) -> V)<(e :: E),a>>))
         -> std/text/parse/@unroll-choose@10000<a,(e :: E)>(ps);
    });
  };
 fun satisfy-fail // inline size: 11
  = forall<a> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(msg: std/core/types/string, pred: (std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>){
    (match ((std/core/hnd/@perform1<(std/core/sslice/sslice) -> (std/core/types/maybe :: V -> V)<(a, std/core/sslice/sslice)>,(std/core/types/maybe :: V -> V)<a>,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> std/text/parse/@select-satisfy<a,(e :: E),b>), pred))) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/hnd/@perform1<std/core/types/string,a,(parse :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e :: E),b> std/text/parse/@select-fail<a,(e :: E),b>), msg);
      ((@skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@0: ((std/core/types/maybe :: V -> V)<a>))
         -> x;
    });
  };
inline  fun next-match // inline size: 3
  = fn(slice: std/core/sslice/sslice, cs: (std/core/types/list :: V -> V)<std/core/types/char>){
    match (cs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/char> ) as @pat: ((std/core/types/list :: V -> V)<std/core/types/char>))
         -> std/core/types/Just<std/core/sslice/sslice>(slice);
      (@pat@0: ((std/core/types/list :: V -> V)<std/core/types/char>))
         -> std/text/parse/@unroll-next-match@10001(slice, cs);
    };
  };
 fun many // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(p: (parser :: (E, V) -> V)<(e :: E),a>){
    std/text/parse/many-acc<a,(e :: E)>(p, (std/core/types/Nil<a>));
  };
 fun many1 // inline size: 3
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(p: (parser :: (E, V) -> V)<(e :: E),a>){
    std/core/types/Cons<a>((p()), (std/text/parse/many-acc<a,(e :: E)>(p, (std/core/types/Nil<a>))));
  };
 fun count // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>|(e :: E)>>(n: std/core/types/int, p: (parser :: (E, V) -> V)<(e :: E),a>){
    std/text/parse/count-acc<a,(e :: E)>(n, (std/core/types/Nil<a>), p);
  };
 fun one-of-or // inline size: 7
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>>(chars: std/core/types/string, default: std/core/types/char){
    match ((std/core/hnd/@perform0<std/core/types/bool,<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(parse :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(parse :: (E, V) -> V)>>((std/core/hnd/@evv-at<(parse :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(parse :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), std/text/parse/@select-pick))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/text/parse/one-of(chars);
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> default;
    };
  };