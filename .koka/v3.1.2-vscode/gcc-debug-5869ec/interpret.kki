module interface interpret
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/core/either = std/core/either = "";
import std/core/exn = std/core/exn = "";
import std/num/random = std/num/random = "";
import etest = etest = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
local alias std/core/pure[52,1,52,26] :: E = <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> = 1;
 
//------------------------------
//#kki: type declarations
 
pub recursive rec type computation[24,1,26,86] {
  pub con Return[25,3,25,8](v: value){0,1,8} : (v : value) -> computation;
  pub con OpCall[26,3,26,8](op: std/core/types/string, k: std/core/types/string, v: value, c: (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation){0,4,8} : (op : std/core/types/string, k : std/core/types/string, v : value, c : (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) -> computation;
};
pub recursive rec type value[18,1,22,6] {
  pub con Int[19,3,19,5](x: std/core/types/int){0,1,8} : (x : std/core/types/int) -> value;
  pub con FnVal[20,3,20,7](x: std/core/types/string, body: expr, env: (std/core/types/list :: V -> V)<(std/core/types/string, value)>){0,3,8} : (x : std/core/types/string, body : expr, env : (std/core/types/list :: V -> V)<(std/core/types/string, value)>) -> value;
  pub con Cont[21,3,21,6](cont: (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation){0,1,8} : (cont : (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) -> value;
  pub con Unit[22,3,22,6]{0,0,0} : value;
};
pub recursive type expr[9,1,16,44] {
  pub con Lit[10,3,10,5](value: value){0,1,8} : (value : value) -> expr;
  pub con Var[11,3,11,5](x: std/core/types/string){0,1,8} : (x : std/core/types/string) -> expr;
  pub con Let[12,3,12,5](name: std/core/types/string, e1: expr, e2: expr){0,3,8} : (name : std/core/types/string, e1 : expr, e2 : expr) -> expr;
  pub con Fn[13,3,13,4](x: std/core/types/string, e1: expr){0,2,8} : (x : std/core/types/string, e1 : expr) -> expr;
  pub con App[14,3,14,5](e1: expr, e2: expr){0,2,8} : (e1 : expr, e2 : expr) -> expr;
  pub con Op[15,3,15,4](op: std/core/types/string, k: std/core/types/string, e: expr){0,3,8} : (op : std/core/types/string, k : std/core/types/string, e : expr) -> expr;
  pub con Handle[16,3,16,8](hs: (std/core/types/list :: V -> V)<(std/core/types/string, hanop)>, e: expr){0,2,8} : (hs : (std/core/types/list :: V -> V)<(std/core/types/string, hanop)>, e : expr) -> expr;
};
pub recursive type hanop[46,1,49,10] {
  pub con Hanop[46,12,46,16](hk: std/core/types/string, he: std/core/types/string, hf: expr){0,3,8} : (hk : std/core/types/string, he : std/core/types/string, hf : expr) -> hanop;
};
pub alias cont[42,1,42,57] = (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation = 1;
pub alias env[40,1,40,37] = (std/core/types/list :: V -> V)<(std/core/types/string, value)> = 1;
pub alias han[44,1,44,37] = (std/core/types/list :: V -> V)<(std/core/types/string, hanop)> = 1;
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `v` constructor field of the `:computation` type.
pub  fun computation/v[25,10,25,10] : (^ computation : computation) -> value;
// Automatically generated. Tests for the `Return` constructor of the `:computation` type.
pub fip fun is-return[25,3,25,8] : (^ computation : computation) -> std/core/types/bool;
// Automatically generated. Tests for the `OpCall` constructor of the `:computation` type.
pub fip fun is-opCall[26,3,26,8] : (^ computation : computation) -> std/core/types/bool;
// Automatically generated. Tests for the `Int` constructor of the `:value` type.
pub fip fun is-int[19,3,19,5] : (^ value : value) -> std/core/types/bool;
// Automatically generated. Tests for the `FnVal` constructor of the `:value` type.
pub fip fun is-fnVal[20,3,20,7] : (^ value : value) -> std/core/types/bool;
// Automatically generated. Tests for the `Cont` constructor of the `:value` type.
pub fip fun is-cont[21,3,21,6] : (^ value : value) -> std/core/types/bool;
// Automatically generated. Tests for the `Unit` constructor of the `:value` type.
pub fip fun is-unit[22,3,22,6] : (^ value : value) -> std/core/types/bool;
// Automatically generated. Tests for the `Lit` constructor of the `:expr` type.
pub fip fun is-lit[10,3,10,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Var` constructor of the `:expr` type.
pub fip fun is-var[11,3,11,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Let` constructor of the `:expr` type.
pub fip fun is-let[12,3,12,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Fn` constructor of the `:expr` type.
pub fip fun is-fn[13,3,13,4] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `App` constructor of the `:expr` type.
pub fip fun is-app[14,3,14,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Op` constructor of the `:expr` type.
pub fip fun is-op[15,3,15,4] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Handle` constructor of the `:expr` type.
pub fip fun is-handle[16,3,16,8] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Retrieves the `hk` constructor field of the `:hanop` type.
pub  fun hanop/hk[47,3,47,4] : (^ hanop : hanop) -> std/core/types/string;
// Automatically generated. Retrieves the `he` constructor field of the `:hanop` type.
pub  fun hanop/he[48,3,48,4] : (^ hanop : hanop) -> std/core/types/string;
// Automatically generated. Retrieves the `hf` constructor field of the `:hanop` type.
pub  fun hanop/hf[49,3,49,4] : (^ hanop : hanop) -> expr;
pub  fun hanop/@copy[46,12,46,16] : (@this : hanop, hk : (std/core/types/@optional :: V -> V)<std/core/types/string>, he : (std/core/types/@optional :: V -> V)<std/core/types/string>, hf : (std/core/types/@optional :: V -> V)<expr>) -> hanop;
pub  fun show[28,9,28,12] : (v : value) -> std/core/types/string;
pub  fun eq[35,9,35,10] : (v1 : value, v2 : value) -> std/core/types/bool;
 fun (==)[110,5,110,8] : (e1 : (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>, e2 : (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>) -> std/core/types/bool;
pub  fun extend[51,9,51,14] : (prev : env, new : (std/core/types/string, value)) -> env;
// monadic lift
 fun @mlift-apply@10049[1,0,1,0] : (c : cont, @y-x10007 : computation) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation;
// monadic lift
 fun @mlift-eval@10050'[1,0,1,0] : (c@0 : cont, i : std/core/types/string, @y-x10014 : (std/core/types/maybe :: V -> V)<(std/core/types/string, value)>) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> computation;
// monadic lift
 fun @mlift-eval@10051'[1,0,1,0] : (c@0 : cont, e@3 : value, env@0 : env, k' : (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation, @y-x10027 : (std/core/types/maybe :: V -> V)<hanop>) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> computation;
// monadic lift
 fun @mlift-eval@10052'[1,0,1,0] : (c@0 : cont, env@0 : env, hs : (std/core/types/list :: V -> V)<(std/core/types/string, hanop)>, e@0' : computation) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation;
pub  fun apply[96,9,96,13] : (f : value, arg : value, c : cont) -> <(std/core/pure :: E),(std/core/console/console :: X)> computation;
pub  fun eval'[57,9,57,13] : (e : expr, env : env, c : cont) -> <(std/core/pure :: E),(std/core/console/console :: X)> computation;
pub  fun eval[54,9,54,12] : (e : expr) -> <(std/core/pure :: E),(std/core/console/console :: X)> computation;
pub  fun run[107,9,107,11] : (e : expr) -> <(std/core/console/console :: X),(std/core/types/div :: X)> (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,computation>;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^"  fun computation/v // inline size: 1
  = fn(computation: computation){
    match (computation) {
      ((interpret/Return((@x: value) : value) : computation ) as @pat: computation)
         -> @x;
      ((@skip interpret/OpCall((@pat@1: std/core/types/string) : std/core/types/string, (@pat@2: std/core/types/string) : std/core/types/string, (@x@0: value) : value, (@pat@3: (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : computation ) as @pat@0: computation)
         -> @x@0;
    };
  };
inline borrow "^" fip fun is-return // inline size: 1
  = fn(computation: computation){
    match (computation) {
      ((interpret/Return((@pat@0: value) : value) : computation ) as @pat: computation)
         -> std/core/types/True;
      ((@skip interpret/OpCall((@pat@2: std/core/types/string) : std/core/types/string, (@pat@3: std/core/types/string) : std/core/types/string, (@pat@4: value) : value, (@pat@5: (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : computation ) as @pat@1: computation)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-opCall // inline size: 1
  = fn(computation: computation){
    match (computation) {
      ((interpret/OpCall((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: std/core/types/string) : std/core/types/string, (@pat@2: value) : value, (@pat@3: (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : computation ) as @pat: computation)
         -> std/core/types/True;
      ((@skip interpret/Return((@pat@5: value) : value) : computation ) as @pat@4: computation)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-int // inline size: 1
  = fn(value: value){
    match (value) {
      ((interpret/Int((@pat@0: std/core/types/int) : std/core/types/int) : value ) as @pat: value)
         -> std/core/types/True;
      (@pat@1: value)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-fnVal // inline size: 1
  = fn(value: value){
    match (value) {
      ((interpret/FnVal((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: expr) : expr, (@pat@2: (std/core/types/list :: V -> V)<(std/core/types/string, value)>) : (std/core/types/list :: V -> V)<(std/core/types/string, value)>) : value ) as @pat: value)
         -> std/core/types/True;
      (@pat@3: value)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-cont // inline size: 1
  = fn(value: value){
    match (value) {
      ((interpret/Cont((@pat@0: (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : (value) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X)> computation) : value ) as @pat: value)
         -> std/core/types/True;
      (@pat@1: value)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-unit // inline size: 1
  = fn(value: value){
    match (value) {
      ((interpret/Unit() : value ) as @pat: value)
         -> std/core/types/True;
      (@pat@0: value)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-lit // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((interpret/Lit((@pat@0: value) : value) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@1: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-var // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((interpret/Var((@pat@0: std/core/types/string) : std/core/types/string) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@1: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-let // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((interpret/Let((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: expr) : expr, (@pat@2: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@3: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-fn // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((interpret/Fn((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@2: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-app // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((interpret/App((@pat@0: expr) : expr, (@pat@1: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@2: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-op // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((interpret/Op((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: std/core/types/string) : std/core/types/string, (@pat@2: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@3: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-handle // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((interpret/Handle((@pat@0: (std/core/types/list :: V -> V)<(std/core/types/string, hanop)>) : (std/core/types/list :: V -> V)<(std/core/types/string, hanop)>, (@pat@1: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@2: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^"  fun hanop/hk // inline size: 0
  = fn(hanop: hanop){
    match (hanop) {
      ((@skip interpret/Hanop((@x: std/core/types/string) : std/core/types/string, (@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: expr) : expr) : hanop ) as @pat: hanop)
         -> @x;
    };
  };
inline borrow "^"  fun hanop/he // inline size: 0
  = fn(hanop: hanop){
    match (hanop) {
      ((@skip interpret/Hanop((@pat@0: std/core/types/string) : std/core/types/string, (@x: std/core/types/string) : std/core/types/string, (@pat@1: expr) : expr) : hanop ) as @pat: hanop)
         -> @x;
    };
  };
inline borrow "^"  fun hanop/hf // inline size: 0
  = fn(hanop: hanop){
    match (hanop) {
      ((@skip interpret/Hanop((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: std/core/types/string) : std/core/types/string, (@x: expr) : expr) : hanop ) as @pat: hanop)
         -> @x;
    };
  };
 fun hanop/@copy // inline size: 4
  = fn(@this: hanop, hk: (std/core/types/@optional :: V -> V)<std/core/types/string>, he: (std/core/types/@optional :: V -> V)<std/core/types/string>, hf: (std/core/types/@optional :: V -> V)<expr>){
    interpret/Hanop((match (hk) {
        ((std/core/types/@Optional((@uniq-hk@273: std/core/types/string) : std/core/types/string) : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
           -> @uniq-hk@273;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
           -> (match (@this) {
            ((@skip interpret/Hanop((@x: std/core/types/string) : std/core/types/string, (@pat@0@0: std/core/types/string) : std/core/types/string, (@pat@1@0: expr) : expr) : hanop ) as @pat@1: hanop)
               -> @x;
          });
      }), (match (he) {
        ((std/core/types/@Optional((@uniq-he@280: std/core/types/string) : std/core/types/string) : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat@1@1: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
           -> @uniq-he@280;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/@optional :: V -> V)<std/core/types/string>))
           -> (match (@this) {
            ((@skip interpret/Hanop((@pat@0@1: std/core/types/string) : std/core/types/string, (@x@0: std/core/types/string) : std/core/types/string, (@pat@1@2: expr) : expr) : hanop ) as @pat@3: hanop)
               -> @x@0;
          });
      }), (match (hf) {
        ((std/core/types/@Optional((@uniq-hf@287: expr) : expr) : (std/core/types/@optional :: V -> V)<expr> ) as @pat@3@0: ((std/core/types/@optional :: V -> V)<expr>))
           -> @uniq-hf@287;
        ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<expr> ) as @pat@4: ((std/core/types/@optional :: V -> V)<expr>))
           -> (match (@this) {
            ((@skip interpret/Hanop((@pat@0@2: std/core/types/string) : std/core/types/string, (@pat@1@3: std/core/types/string) : std/core/types/string, (@x@1: expr) : expr) : hanop ) as @pat@5: hanop)
               -> @x@1;
          });
      }));
  };
 fun eq // inline size: 2
  = fn(v1: value, v2: value){
    match (v1, v2) {
      ((interpret/Int((i2: std/core/types/int) : std/core/types/int) : value ) as @pat@1: value), ((interpret/Int((i1: std/core/types/int) : std/core/types/int) : value ) as @pat@0: value)
         -> std/core/int/(==)(i1, i2);
      (@pat@2: value), (@pat: value)
         -> std/core/types/False;
    };
  };
 fun (==) // inline size: 4
  = fn(e1: (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>, e2: (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>){
    match (e1, e2) {
      ((std/core/types/Right((r2: value) : value) : (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value> ) as @pat@1: (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>), ((std/core/types/Right((r1: value) : value) : (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value> ) as @pat@0: ((std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>))
         -> (match (r1, r2) {
          ((interpret/Int((i2: std/core/types/int) : std/core/types/int) : value ) as @pat@1@0: value), ((interpret/Int((i1: std/core/types/int) : std/core/types/int) : value ) as @pat@0@0: value)
             -> std/core/int/(==)(i1, i2);
          (@pat@2: value), (@pat: value)
             -> std/core/types/False;
        });
      ((std/core/types/Left(((@skip std/core/exn/Exception((@pat@7: std/core/types/string) : std/core/types/string, (@pat@8: std/core/exn/exception-info) : std/core/exn/exception-info) : std/core/exn/exception ) as e2@0: std/core/exn/exception) : std/core/exn/exception) : (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value> ) as @pat@6: (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>), ((std/core/types/Left(((@skip std/core/exn/Exception((@pat@4: std/core/types/string) : std/core/types/string, (@pat@5: std/core/exn/exception-info) : std/core/exn/exception-info) : std/core/exn/exception ) as e1@0: std/core/exn/exception) : std/core/exn/exception) : (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value> ) as @pat@3: ((std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>))
         -> std/core/types/True;
      (@pat@2@0: ((std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>)), (@pat@9: ((std/core/types/either :: (V, V) -> V)<std/core/exn/exception,value>))
         -> std/core/types/False;
    };
  };
 fun extend // inline size: 2
  = fn(prev: env, new: (std/core/types/string, value)){
    std/core/list/append<(std/core/types/string, value)>(prev, (std/core/types/Cons<(std/core/types/string, value)>(new, (std/core/types/Nil<(std/core/types/string, value)>))));
  };
 fun eval // inline size: 2
  = fn<<(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(e: expr){
    interpret/eval'(e, (std/core/types/Nil<(std/core/types/string, value)>), (fn<<(std/core/pure :: E),(std/core/console/console :: X)>>(x: value){
        (interpret/Return(x));
      }));
  };