// Standard `:list` functions.
module interface std/core/list
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
import std/core/undiv = std/core/undiv = "";
import std/core/hnd = std/core/hnd = "";
import std/core/exn = std/core/exn = "";
import std/core/char = std/core/char = "";
import std/core/string = std/core/string = "";
import std/core/int = std/core/int = "";
import std/core/vector = std/core/vector = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// A first-class constructor context where the hole is of the same type as the root of the structure.
local alias std/core/types/ctx[483,1,483,28]<a> :: V -> V = (std/core/types/cctx :: (V, V) -> V)<a,a> = 1;
 
//------------------------------
//#kki: type declarations
 
 
//------------------------------
//#kki: declarations
 
// Return the head of list if the list is not empty.
pub  fun head[23,9,23,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the head of list with a default value in case the list is empty.
pub  fun default/head[29,9,29,20] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, default : a) -> a;
// Return the tail of list. Returns the empty list if `xs` is empty.
pub  fun tail[35,9,35,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Is the list empty?
pub  fun is-empty[41,9,41,16] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> std/core/types/bool;
// Returns a singleton list.
pub  fun single[52,9,52,14] : forall<a> (x : a) -> (std/core/types/list :: V -> V)<a>;
// lifted local: length, len
 fun @unroll-lift-length@4947@10000[1,0,1,0] : forall<a> (ys : (std/core/types/list :: V -> V)<a>, acc : std/core/types/int) -> std/core/types/int;
// unrolling of singleton matches of std/core/list/@unroll-lift-length@4947@10000
 fun @lift-length@4947[1,0,1,0] : forall<a> (ys : (std/core/types/list :: V -> V)<a>, acc : std/core/types/int) -> std/core/types/int;
// Returns the length of a list.
pub  fun length[56,9,56,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> std/core/types/int;
// Element-wise list equality
 fun (@unroll-x@10001==)[98,9,98,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> std/core/types/bool) -> std/core/types/bool;
// unrolling of singleton matches of std/core/list/(@unroll-x@10001==)
pub  fun (==)[98,9,98,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, ?(==) : (a, a) -> std/core/types/bool) -> std/core/types/bool;
// Order on lists
 fun @unroll-cmp@10002[108,9,108,11] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, ?cmp : (a, a) -> std/core/types/order) -> std/core/types/order;
// unrolling of singleton matches of std/core/list/@unroll-cmp@10002
pub  fun cmp[108,9,108,11] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, ?cmp : (a, a) -> std/core/types/order) -> std/core/types/order;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub  fun @trmc-take[189,9,189,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub  fun take[189,9,189,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/list :: V -> V)<a>;
// Drop the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub  fun drop[195,9,195,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/list :: V -> V)<a>;
// lifted local: reverse-append, reverse-acc
 fun @unroll-lift-reverse-append@4948@10003[1,0,1,0] : forall<a> (acc : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-lift-reverse-append@4948@10003
 fun @lift-reverse-append@4948[1,0,1,0] : forall<a> (acc : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Efficiently reverse a list `xs` and append it to `tl`:
// `reverse-append(xs,tl) == reserve(xs) ++ tl
pub  fun reverse-append[239,9,239,22] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, tl : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Reverse a list.
pub  fun reverse[234,9,234,15] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Append two lists.
 fun @trmc-unroll-append@10004[251,9,251,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Append two lists.
 fun @unroll-append@10004[251,9,251,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-append@10004
pub  fun append[251,9,251,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Append two lists.
pub  fun (++)[247,9,247,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-unroll-foldl@10005@10684[1,0,1,0] : forall<a,b,(e :: E)> (f : (b, a) -> (e :: E) b, xx : (std/core/types/list :: V -> V)<a>, @y-x10440 : b) -> (e :: E) b;
// Fold a list from the left, i.e. `foldl([1,2],0,(+)) == (0+1)+2`
// Since `foldl` is tail recursive, it is preferred over `foldr` when using an associative function `f`
 fun @unroll-foldl@10005[263,9,263,13] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, z : b, f : (b, a) -> (e :: E) b) -> (e :: E) b;
// unrolling of singleton matches of std/core/list/@unroll-foldl@10005
pub  fun foldl[263,9,263,13] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, z : b, f : (b, a) -> (e :: E) b) -> (e :: E) b;
// monadic lift
 fun @mlift-lift-foldr@10363@10685[1,0,1,0] : forall<a,b,(e :: E)> (@uniq-xx@10288 : (std/core/types/list :: V -> V)<a>, f : (a, b) -> (e :: E) b, @uniq-z@10284@0@10373 : b) -> (e :: E) b;
// lifted local: foldr, @spec-x10290
// specialized: std/core/list/@unroll-foldl@10005, on parameters @uniq-f@10285, using:
// @uniq-f@10285 = fn<(e :: E)>(x: 1117, y: 1116){
//   f(y, x);
// }
 fun @lift-foldr@10363[1,0,1,0] : forall<a,b,(e :: E)> (f : (a, b) -> (e :: E) b, @uniq-xs@10283 : (std/core/types/list :: V -> V)<a>, @uniq-z@10284 : b) -> (e :: E) b;
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)`
// Note, `foldr` is less efficient than `foldl` as it reverses the list first.
pub  fun foldr[258,9,258,13] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, z : b, f : (a, b) -> (e :: E) b) -> (e :: E) b;
pub  fun foldl1[268,9,268,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a;
pub  fun foldr1[273,9,273,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a;
// split a list at position `n`
pub  fun split[283,9,283,13] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// monadic lift
 fun @mlift-unroll-drop-while@10006@10686[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xs : (std/core/types/list :: V -> V)<a>, xx : (std/core/types/list :: V -> V)<a>, @y-x10460 : std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Drop all initial elements that satisfy `predicate`
 fun @unroll-drop-while@10006[301,9,301,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-drop-while@10006
pub  fun drop-while[301,9,301,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-unroll-filter@10007@10687[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (std/core/types/list :: V -> V)<a>, @y-x10466 : std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
 fun @trmc-unroll-filter@10007[308,9,308,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
 fun @unroll-filter@10007[308,9,308,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-filter@10007
pub  fun filter[308,9,308,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-unroll-filter-map@10008@10688[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10474 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if i.odd? then Nothing else Just(i*i) }) == [4]`
 fun @trmc-unroll-filter-map@10008[333,9,333,18] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if i.odd? then Nothing else Just(i*i) }) == [4]`
 fun @unroll-filter-map@10008[333,9,333,18] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-filter-map@10008
pub  fun filter-map[333,9,333,18] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-unroll-foreach-while@10009@10689[1,0,1,0] : forall<a,b,(e :: E)> (action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10482 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Invoke `action` for each element of a list while `action` return `Nothing`
 fun @unroll-foreach-while@10009[378,9,378,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-foreach-while@10009
pub  fun foreach-while[378,9,378,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
 fun @mlift-lift-find@10364@10690[1,0,1,0] : forall<a,(e :: E)> (@uniq-x@10297 : a, @uniq-xx@10298 : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, @y-x10488 : std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// lifted local: find, @spec-x10301
// specialized: std/core/list/@unroll-foreach-while@10009, on parameters @uniq-action@10294, using:
// @uniq-action@10294 = fn<(e :: E)>(x: 1515){
//   match ((pred(x))) {
//     ((std/core/types/True() : bool ) as @pat@1: bool)
//        -> std/core/types/Just<a>(x);
//     ((@skip std/core/types/False() : bool ) as @pat@0@0: bool)
//        -> std/core/types/Nothing<a>;
//   };
// }
 fun @lift-find@10364[1,0,1,0] : forall<a,(e :: E)> (pred : (a) -> (e :: E) std/core/types/bool, @uniq-xs@10293 : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Find the first element satisfying some predicate
pub  fun find[341,9,341,12] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Find the first element satisfying some predicate and return it.
pub  fun find-maybe[346,9,346,18] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Convert a `:maybe` type to a list type.
pub  fun maybe/list[356,9,356,18] : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun @trmc-list[66,9,66,12] : (lo : std/core/types/int, hi : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/int>>) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun list[66,9,66,12] : (lo : std/core/types/int, hi : std/core/types/int) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// monadic lift
 fun @mlift-trmc-unroll-map@10010@10691[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (a) -> (e :: E) b, xx : (std/core/types/list :: V -> V)<a>, @trmc-x10389 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f` to each element of the input list in sequence.
 fun @trmc-unroll-map@10010[201,9,201,11] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) b, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f` to each element of the input list in sequence.
 fun @unroll-map@10010[201,9,201,11] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-map@10010
pub  fun map[201,9,201,11] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: char/list, @spec-x10309
// specialized: std/core/list/@unroll-map@10010, on parameters @uniq-f@10304, using:
// @uniq-f@10304 = std/core/char/int/char
 fun char/@trmc-lift-list@10365[1,0,1,0] : (@uniq-xs@10303 : (std/core/types/list :: V -> V)<std/core/types/int>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/char>>) -> (std/core/types/list :: V -> V)<std/core/types/char>;
// lifted local: char/list, @spec-x10309
// specialized: std/core/list/@unroll-map@10010, on parameters @uniq-f@10304, using:
// @uniq-f@10304 = std/core/char/int/char
 fun char/@lift-list@10365[1,0,1,0] : (@uniq-xs@10303 : (std/core/types/list :: V -> V)<std/core/types/int>) -> (std/core/types/list :: V -> V)<std/core/types/char>;
// Create a list of characters from `lo`  to `hi`  (including `hi`).
pub  fun char/list[94,9,94,17] : (lo : std/core/types/char, hi : std/core/types/char) -> (std/core/types/list :: V -> V)<std/core/types/char>;
// monadic lift
 fun function/@mlift-trmc-list@10692[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, @trmc-x10395 : a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun function/@trmc-list[81,9,81,21] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub  fun function/list[81,9,81,21] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stride/@trmc-list[73,9,73,19] : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<std/core/types/int>>) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stride/list[73,9,73,19] : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int) -> (std/core/types/list :: V -> V)<std/core/types/int>;
// monadic lift
 fun stridefunction/@mlift-trmc-list@10693[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, stride : std/core/types/int, @trmc-x10400 : a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stridefunction/@trmc-list[88,9,88,27] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub  fun stridefunction/list[88,9,88,27] : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Apply a function `f` to each character in a string
pub  fun string/map[542,9,542,18] : forall<(e :: E)> (s : std/core/types/string, f : (std/core/types/char) -> (e :: E) std/core/types/char) -> (e :: E) std/core/types/string;
// monadic lift
 fun @mlift-trmc-unroll-lift-map-indexed@4949@10011@10694[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (idx : std/core/types/int, value : a) -> (e :: E) b, i@0@10069 : std/core/types/int, yy : (std/core/types/list :: V -> V)<a>, @trmc-x10403 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed, map-idx
 fun @trmc-unroll-lift-map-indexed@4949@10011[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed, map-idx
 fun @unroll-lift-map-indexed@4949@10011[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-lift-map-indexed@4949@10011
 fun @lift-map-indexed@4949[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f` to each element of the input list in sequence where takes
// both the index of the current element and the element itself as arguments.
pub  fun map-indexed[208,9,208,19] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (idx : std/core/types/int, value : a) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-trmc-unroll-lift-map-peek@4950@10012@10695[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, yy : (std/core/types/list :: V -> V)<a>, @trmc-x10406 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-peek, mappeek
 fun @trmc-unroll-lift-map-peek@4950@10012[1,0,1,0] : forall<a,b,(e :: E)> (f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-peek, mappeek
 fun @unroll-lift-map-peek@4950@10012[1,0,1,0] : forall<a,b,(e :: E)> (f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-lift-map-peek@4950@10012
 fun @lift-map-peek@4950[1,0,1,0] : forall<a,b,(e :: E)> (f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f` to each element of the input list in sequence where `f` takes
// both the current element and the tail list as arguments.
pub  fun map-peek[217,9,217,16] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-trmc-unroll-lift-map-indexed-peek@4951@10013@10696[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, i@0@10077 : std/core/types/int, yy : (std/core/types/list :: V -> V)<a>, @trmc-x10409 : b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed-peek, mapidx
 fun @trmc-unroll-lift-map-indexed-peek@4951@10013[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: map-indexed-peek, mapidx
 fun @unroll-lift-map-indexed-peek@4951@10013[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-lift-map-indexed-peek@4951@10013
 fun @lift-map-indexed-peek@4951[1,0,1,0] : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys : (std/core/types/list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Apply a function `f` to each element of the input list in sequence where takes
// both the index of the current element, the element itself, and the tail list as arguments.
pub  fun map-indexed-peek[226,9,226,24] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Create a list of `n` repeated elements `x`
pub  fun @trmc-replicate[277,9,277,17] : forall<a> (x : a, n : std/core/types/int, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Create a list of `n` repeated elements `x`
pub  fun replicate[277,9,277,17] : forall<a> (x : a, n : std/core/types/int) -> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-lift-remove@10366@10697[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, @uniq-x@10313 : a, @uniq-xx@10314 : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, @y-x10537 : std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// lifted local: remove, @spec-x10318
// specialized: std/core/list/@unroll-filter@10007, on parameters @uniq-pred@10311, using:
// @uniq-pred@10311 = fn<(e :: E)>(x: 2269){
//   std/core/types/@open<(total :: E),(e :: E),(b : bool) -> bool,(b : bool) -> (e :: E) bool>((fn(b: bool){
//     (match (b) {
//       ((std/core/types/True() : bool ) as @pat@0: bool)
//          -> std/core/types/False;
//       ((@skip std/core/types/False() : bool ) as @pat@0@0: bool)
//          -> std/core/types/True;
//     });
//   }))((pred(x)));
// }
 fun @trmc-lift-remove@10366[1,0,1,0] : forall<a,(e :: E)> (pred : (a) -> (e :: E) std/core/types/bool, @uniq-xs@10310 : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// lifted local: remove, @spec-x10318
// specialized: std/core/list/@unroll-filter@10007, on parameters @uniq-pred@10311, using:
// @uniq-pred@10311 = fn<(e :: E)>(x: 2269){
//   std/core/types/@open<(total :: E),(e :: E),(b : bool) -> bool,(b : bool) -> (e :: E) bool>((fn(b: bool){
//     (match (b) {
//       ((std/core/types/True() : bool ) as @pat@0: bool)
//          -> std/core/types/False;
//       ((@skip std/core/types/False() : bool ) as @pat@0@0: bool)
//          -> std/core/types/True;
//     });
//   }))((pred(x)));
// }
 fun @lift-remove@10366[1,0,1,0] : forall<a,(e :: E)> (pred : (a) -> (e :: E) std/core/types/bool, @uniq-xs@10310 : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Remove those elements of a list that satisfy the given predicate `pred`.
// For example: `remove([1,2,3],odd?) == [2]`
pub  fun remove[315,9,315,14] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-unroll-partition-acc@10014@10698[1,0,1,0] : forall<a,(e :: E)> (acc1 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (std/core/types/list :: V -> V)<a>, @y-x10545 : std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
 fun @unroll-partition-acc@10014[324,5,324,17] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ^ pred : (a) -> (e :: E) std/core/types/bool, acc1 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// unrolling of singleton matches of std/core/list/@unroll-partition-acc@10014
 fun partition-acc[324,5,324,17] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ^ pred : (a) -> (e :: E) std/core/types/bool, acc1 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// Partition a list in two lists where the first list contains
// those elements that satisfy the given predicate `pred`.
// For example: `partition([1,2,3],odd?) == ([1,3],[2])`
pub  fun partition[321,9,321,17] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ^ pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// monadic lift
 fun @mlift-lift-lookup@10367@10699[1,0,1,0] : forall<a,b,(e :: E)> (@uniq-x@10324 : (a, b), @uniq-xx@10325 : (std/core/types/list :: V -> V)<(a, b)>, pred : (a) -> (e :: E) std/core/types/bool, @y-x10554 : std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// lifted local: lookup, @spec-x10328
// specialized: std/core/list/@unroll-foreach-while@10009, on parameters @uniq-action@10321, using:
// @uniq-action@10321 = fn<(e :: E)>(kv: (2578, 2579)){
//   match ((pred((std/core/types/@open<(total :: E),(e :: E),(tuple2 : (a, b)) -> a,(tuple2 : (a, b)) -> (e :: E) a>((fn(tuple2: (2578, 2579)){
//     (match (tuple2) {
//       ((@skip std/core/types/Tuple2((@x: 2578) : a, (@pat@0@0: 2579) : a) : (a, b) ) as @pat@1: (2578, 2579))
//          -> @x;
//     });
//   }))(kv))))) {
//     ((std/core/types/True() : bool ) as @pat@2: bool)
//        -> std/core/types/Just<a>((std/core/types/@open<(total :: E),(e :: E),(tuple2 : (a, b)) -> b,(tuple2 : (a, b)) -> (e :: E) b>((fn(tuple2@0: (2578, 2579)){
//         (match (tuple2@0) {
//           ((@skip std/core/types/Tuple2((@pat@0@1: 2578) : a, (@x@0: 2579) : a) : (a, b) ) as @pat@3: (2578, 2579))
//              -> @x@0;
//         });
//       }))(kv)));
//     ((@skip std/core/types/False() : bool ) as @pat@0@2: bool)
//        -> std/core/types/Nothing<a>;
//   };
// }
 fun @lift-lookup@10367[1,0,1,0] : forall<a,b,(e :: E)> (pred : (a) -> (e :: E) std/core/types/bool, @uniq-xs@10320 : (std/core/types/list :: V -> V)<(a, b)>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Lookup the first element satisfying some predicate
pub  fun lookup[350,9,350,14] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<(a, b)>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
 fun @mlift-unroll-index-of-acc@10015@10700[1,0,1,0] : forall<a,(e :: E)> (idx : std/core/types/int, pred : (a) -> (e :: E) std/core/types/bool, xx : (std/core/types/list :: V -> V)<a>, @y-x10561 : std/core/types/bool) -> (e :: E) std/core/types/int;
 fun @unroll-index-of-acc@10015[361,5,361,16] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, idx : std/core/types/int) -> (e :: E) std/core/types/int;
// unrolling of singleton matches of std/core/list/@unroll-index-of-acc@10015
 fun index-of-acc[361,5,361,16] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, idx : std/core/types/int) -> (e :: E) std/core/types/int;
// Returns the index of the first element where `pred` holds, or `-1` if no such element exists.
pub  fun index-of[368,9,368,16] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/int;
// monadic lift
 fun @mlift-unroll-foreach@10016@10701[1,0,1,0] : forall<a,(e :: E)> (action : (a) -> (e :: E) (), xx : (std/core/types/list :: V -> V)<a>, wild_ : ()) -> (e :: E) ();
// Invoke `action` for each element of a list
 fun @unroll-foreach@10016[372,9,372,15] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) ()) -> (e :: E) ();
// unrolling of singleton matches of std/core/list/@unroll-foreach@10016
pub  fun foreach[372,9,372,15] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
 fun @mlift-trmc-unroll-map-while@10017@10702[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10574 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
 fun @trmc-unroll-map-while@10017[387,9,387,17] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
 fun @unroll-map-while@10017[387,9,387,17] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-map-while@10017
pub  fun map-while[387,9,387,17] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-lift-foreach-indexed@10368@10703[1,0,1,0] : forall<(h :: H),a,(e :: E)> (@uniq-xx@10334 : (std/core/types/list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, @uniq-x_@10335 : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
 fun @mlift-lift-foreach-indexed@10368@10704[1,0,1,0] : forall<(h :: H),a,(e :: E)> (@uniq-xx@10334 : (std/core/types/list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, @y-x10584 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
 fun @mlift-lift-foreach-indexed@10368@10705[1,0,1,0] : forall<(h :: H),a,(e :: E)> (@uniq-xx@10334 : (std/core/types/list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
 fun @mlift-lift-foreach-indexed@10368@10706[1,0,1,0] : forall<(h :: H),a,(e :: E)> (@uniq-x@10333 : a, @uniq-xx@10334 : (std/core/types/list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, j : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// lifted local: foreach-indexed, @spec-x10337
// specialized: std/core/list/@unroll-foreach@10016, on parameters @uniq-action@10331, using:
// @uniq-action@10331 = fn<<(local :: H -> X)<(h :: H)>|(e :: E)>>(x: 2870){
//   val j : int;
//   val _ : ();
//   std/core/types/local-set<int,(e :: E),(h :: H)>(i, (std/core/types/@open<(total :: E),<(local :: H -> X)<(h :: H)>|(e :: E)>,(x : int, y : int) -> int,(x : int, y : int) -> <(local :: H -> X)<(h :: H)>|(e :: E)> int>((fn(x@0: int, y: int){
//       (std/core/int/int-add(x@0, y));
//     }))((std/core/types/local-get<int,(h :: H),(e :: E)>(i)), 1)));
// }
 fun @lift-foreach-indexed@10368[1,0,1,0] : forall<(h :: H),a,(e :: E)> (action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, @uniq-xs@10330 : (std/core/types/list :: V -> V)<a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// Invoke `action` for each element of a list, passing also the position of the element.
pub  fun foreach-indexed[397,9,397,23] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) ()) -> (e :: E) ();
// lifted local: intersperse, before
 fun @trmc-unroll-lift-intersperse@4952@10018[1,0,1,0] : forall<a> (sep : a, ys : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// lifted local: intersperse, before
 fun @unroll-lift-intersperse@4952@10018[1,0,1,0] : forall<a> (sep : a, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-lift-intersperse@4952@10018
 fun @lift-intersperse@4952[1,0,1,0] : forall<a> (sep : a, ys : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Insert a separator `sep`  between all elements of a list `xs` .
pub  fun intersperse[405,9,405,19] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, sep : a) -> (std/core/types/list :: V -> V)<a>;
// Concatenate all strings in a list
pub  fun join[423,9,423,12] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Concatenate all strings in a list
 fun joinsep[415,5,415,11] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list using a specific separator
pub  fun joinsep/join[431,9,431,20] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
// monadic lift
 fun @mlift-show@10707[1,0,1,0] : (@c-x10593 : (std/core/types/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Show a list
pub  fun show[121,9,121,12] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ?show : (a) -> (e :: E) std/core/types/string) -> (e :: E) std/core/types/string;
// _deprecated_, use `list/show` instead.
pub  fun show-list[126,9,126,17] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, show-elem : (a) -> (e :: E) std/core/types/string) -> (e :: E) std/core/types/string;
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
 fun @trmc-unroll-zip@10019[133,9,133,11] : forall<a,b> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<(a, b)>>) -> (std/core/types/list :: V -> V)<(a, b)>;
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
 fun @unroll-zip@10019[133,9,133,11] : forall<a,b> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>) -> (std/core/types/list :: V -> V)<(a, b)>;
// unrolling of singleton matches of std/core/list/@unroll-zip@10019
pub  fun zip[133,9,133,11] : forall<a,b> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>) -> (std/core/types/list :: V -> V)<(a, b)>;
// monadic lift
 fun @mlift-trmc-unroll-zipwith@10020@10708[1,0,1,0] : forall<a,b,c,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>, f : (a, b) -> (e :: E) c, xx : (std/core/types/list :: V -> V)<a>, yy : (std/core/types/list :: V -> V)<b>, @trmc-x10422 : c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
 fun @trmc-unroll-zipwith@10020[142,9,142,15] : forall<a,b,c,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, f : (a, b) -> (e :: E) c, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
 fun @unroll-zipwith@10020[142,9,142,15] : forall<a,b,c,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, f : (a, b) -> (e :: E) c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// unrolling of singleton matches of std/core/list/@unroll-zipwith@10020
pub  fun zipwith[142,9,142,15] : forall<a,b,c,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, f : (a, b) -> (e :: E) c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// monadic lift
 fun @mlift-trmc-unroll-lift-zipwith-indexed@4953@10021@10709[1,0,1,0] : forall<a,b,c,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>, f : (std/core/types/int, a, b) -> (e :: E) c, i@0@10105 : std/core/types/int, xx : (std/core/types/list :: V -> V)<a>, yy : (std/core/types/list :: V -> V)<b>, @trmc-x10425 : c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// lifted local: zipwith-indexed, zipwith-iter
 fun @trmc-unroll-lift-zipwith-indexed@4953@10021[1,0,1,0] : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// lifted local: zipwith-indexed, zipwith-iter
 fun @unroll-lift-zipwith-indexed@4953@10021[1,0,1,0] : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// unrolling of singleton matches of std/core/list/@unroll-lift-zipwith-indexed@4953@10021
 fun @lift-zipwith-indexed@4953[1,0,1,0] : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (std/core/types/list :: V -> V)<a>, ys : (std/core/types/list :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
pub  fun zipwith-indexed[152,9,152,23] : forall<a,b,c,(e :: E)> (xs0 : (std/core/types/list :: V -> V)<a>, ys0 : (std/core/types/list :: V -> V)<b>, f : (std/core/types/int, a, b) -> (e :: E) c) -> (e :: E) (std/core/types/list :: V -> V)<c>;
// lifted local: unzip, iter
// todo: implement TRMC for multiple results
 fun @unroll-lift-unzip@4954@10022[1,0,1,0] : forall<a,b,c,d> (ys : (std/core/types/list :: V -> V)<(a, b)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<c,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<b>>) -> (c, d);
// unrolling of singleton matches of std/core/list/@unroll-lift-unzip@4954@10022
 fun @lift-unzip@4954[1,0,1,0] : forall<a,b,c,d> (ys : (std/core/types/list :: V -> V)<(a, b)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<c,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<b>>) -> (c, d);
// Unzip a list of pairs into two lists
pub  fun unzip[162,9,162,13] : forall<a,b> (xs : (std/core/types/list :: V -> V)<(a, b)>) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<b>);
// lifted local: unzip3, iter
// todo: implement TRMC for multiple results
 fun @unroll-lift-unzip3@4955@10023[1,0,1,0] : forall<a,b,c,d,a1,b1> (ys : (std/core/types/list :: V -> V)<(a, b, c)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<b>>, acc3 : (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<c>>) -> (d, a1, b1);
// unrolling of singleton matches of std/core/list/@unroll-lift-unzip3@4955@10023
 fun @lift-unzip3@4955[1,0,1,0] : forall<a,b,c,d,a1,b1> (ys : (std/core/types/list :: V -> V)<(a, b, c)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<b>>, acc3 : (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<c>>) -> (d, a1, b1);
// Unzip a list of triples into three lists
pub  fun unzip3[171,9,171,14] : forall<a,b,c> (xs : (std/core/types/list :: V -> V)<(a, b, c)>) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<b>, (std/core/types/list :: V -> V)<c>);
// lifted local: unzip4, iter
// todo: implement TRMC for multiple results
 fun @unroll-lift-unzip4@4956@10024[1,0,1,0] : forall<a,b,c,d,a1,b1,c1,d1> (ys : (std/core/types/list :: V -> V)<(a, b, c, d)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<b>>, acc3 : (std/core/types/cctx :: (V, V) -> V)<c1,(std/core/types/list :: V -> V)<c>>, acc4 : (std/core/types/cctx :: (V, V) -> V)<d1,(std/core/types/list :: V -> V)<d>>) -> (a1, b1, c1, d1);
// unrolling of singleton matches of std/core/list/@unroll-lift-unzip4@4956@10024
 fun @lift-unzip4@4956[1,0,1,0] : forall<a,b,c,d,a1,b1,c1,d1> (ys : (std/core/types/list :: V -> V)<(a, b, c, d)>, acc1 : (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<a>>, acc2 : (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<b>>, acc3 : (std/core/types/cctx :: (V, V) -> V)<c1,(std/core/types/list :: V -> V)<c>>, acc4 : (std/core/types/cctx :: (V, V) -> V)<d1,(std/core/types/list :: V -> V)<d>>) -> (a1, b1, c1, d1);
// Unzip a list of quadruples into four lists
pub  fun unzip4[180,9,180,14] : forall<a,b,c,d> (xs : (std/core/types/list :: V -> V)<(a, b, c, d)>) -> ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<b>, (std/core/types/list :: V -> V)<c>, (std/core/types/list :: V -> V)<d>);
// monadic lift
 fun @mlift-unroll-lift-span@4957@10025@10710[1,0,1,0] : forall<a,(e :: E)> (acc : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, y : a, ys : (std/core/types/list :: V -> V)<a>, yy : (std/core/types/list :: V -> V)<a>, @y-x10611 : std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// lifted local: span, span-acc
// todo: implement TRMC with multiple results to avoid the reverse
 fun @unroll-lift-span@4957@10025[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, ys : (std/core/types/list :: V -> V)<a>, acc : (std/core/types/list :: V -> V)<a>) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// unrolling of singleton matches of std/core/list/@unroll-lift-span@4957@10025
 fun @lift-span@4957[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, ys : (std/core/types/list :: V -> V)<a>, acc : (std/core/types/list :: V -> V)<a>) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
pub  fun span[286,9,286,12] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((std/core/types/list :: V -> V)<a>, (std/core/types/list :: V -> V)<a>);
// monadic lift
 fun @mlift-trmc-unroll-take-while@10026@10711[1,0,1,0] : forall<a,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, predicate : (a) -> (e :: E) std/core/types/bool, x : a, xx : (std/core/types/list :: V -> V)<a>, @y-x10619 : std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
 fun @trmc-unroll-take-while@10026[295,9,295,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
 fun @unroll-take-while@10026[295,9,295,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-take-while@10026
pub  fun take-while[295,9,295,18] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (std/core/types/list :: V -> V)<a>;
// Concatenate all strings in a list in reverse order
pub  fun reverse-join[435,9,435,20] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Append `end` to each string in the list `xs` and join them all together.\
// `join-end([],end) === ""`\
// `join-end(["a","b"],"/") === "a/b/"`
pub  fun join-end[441,9,441,16] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>, end : std/core/types/string) -> std/core/types/string;
// lifted local: concat, concat-pre
 fun @trmc-lift-concat@4958[1,0,1,0] : forall<a> (ys : (std/core/types/list :: V -> V)<a>, zss : (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// lifted local: concat, concat-pre
 fun @lift-concat@4958[1,0,1,0] : forall<a> (ys : (std/core/types/list :: V -> V)<a>, zss : (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Concatenate all lists in a list (e.g. flatten the list). (tail-recursive)
pub  fun concat[447,9,447,14] : forall<a> (xss : (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// monadic lift
 fun @mlift-trmc-lift-flatmap@4959@10712[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, zz : (std/core/types/list :: V -> V)<a>, ys@1@10132 : (std/core/types/list :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: flatmap, flatmap-pre
 fun @trmc-lift-flatmap@4959[1,0,1,0] : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, ys : (std/core/types/list :: V -> V)<b>, zs : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// lifted local: flatmap, flatmap-pre
 fun @lift-flatmap@4959[1,0,1,0] : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, ys : (std/core/types/list :: V -> V)<b>, zs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Concatenate the result lists from applying a function to all elements.
pub  fun flatmap[457,9,457,15] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/list :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// monadic lift
 fun @mlift-trmc-unroll-flatmap-maybe@10027@10713[1,0,1,0] : forall<a,b,(e :: E)> (@acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (std/core/types/list :: V -> V)<a>, @y-x10633 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
 fun @trmc-unroll-flatmap-maybe@10027[467,9,467,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
 fun @unroll-flatmap-maybe@10027[467,9,467,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// unrolling of singleton matches of std/core/list/@unroll-flatmap-maybe@10027
pub  fun flatmap-maybe[467,9,467,21] : forall<a,b,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/list :: V -> V)<b>;
// Concatenate a list of `:maybe` values
 fun @trmc-unroll-concat-maybe@10028[475,9,475,20] : forall<a> (xs : (std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Concatenate a list of `:maybe` values
 fun @unroll-concat-maybe@10028[475,9,475,20] : forall<a> (xs : (std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-concat-maybe@10028
pub  fun concat-maybe[475,9,475,20] : forall<a> (xs : (std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Return the last element of a list (or `Nothing` for the empty list)
pub  fun last[483,9,483,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the list without its last element.
// Return an empty list for an empty list.
pub  fun @trmc-init[491,9,491,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, @acc : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>) -> (std/core/types/list :: V -> V)<a>;
// Return the list without its last element.
// Return an empty list for an empty list.
pub  fun init[491,9,491,12] : forall<a> (xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>;
// Get (zero-based) element `n`  of a list. Return a `:maybe` type.
 fun @unroll-index@10029[497,9,497,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/maybe :: V -> V)<a>;
// unrolling of singleton matches of std/core/list/@unroll-index@10029
pub  fun @index[497,9,497,14] : forall<a> (xs : (std/core/types/list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/maybe :: V -> V)<a>;
// monadic lift
 fun @mlift-unroll-all@10030@10714[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (std/core/types/list :: V -> V)<a>, @y-x10641 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Do all elements satisfy a predicate ?
 fun @unroll-all@10030[505,9,505,11] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// unrolling of singleton matches of std/core/list/@unroll-all@10030
pub  fun all[505,9,505,11] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// monadic lift
 fun @mlift-unroll-any@10031@10715[1,0,1,0] : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (std/core/types/list :: V -> V)<a>, @y-x10647 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Are there any elements in a list that satisfy a predicate ?
 fun @unroll-any@10031[511,9,511,11] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// unrolling of singleton matches of std/core/list/@unroll-any@10031
pub  fun any[511,9,511,11] : forall<a,(e :: E)> (xs : (std/core/types/list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// lifted local: sum, @spec-x10346
// specialized: std/core/list/@unroll-foldl@10005, on parameters @uniq-f@10341, using:
// @uniq-f@10341 = std/core/int/(+)
 fun @lift-sum@10369[1,0,1,0] : (@uniq-xs@10339 : (std/core/types/list :: V -> V)<std/core/types/int>, @uniq-z@10340 : std/core/types/int) -> std/core/types/int;
// Return the sum of a list of integers
pub  fun sum[517,9,517,11] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>) -> std/core/types/int;
// lifted local: minimum, @spec-x10354
// specialized: std/core/list/@unroll-foldl@10005, on parameters @uniq-f@10349, using:
// @uniq-f@10349 = std/core/int/min
 fun @lift-minimum@10370[1,0,1,0] : (@uniq-xs@10347 : (std/core/types/list :: V -> V)<std/core/types/int>, @uniq-z@10348 : std/core/types/int) -> std/core/types/int;
// Returns the smallest element of a list of integers (or `default` (=`0`) for the empty list)
pub  fun minimum[521,9,521,15] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>, default : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// lifted local: maximum, @spec-x10362
// specialized: std/core/list/@unroll-foldl@10005, on parameters @uniq-f@10357, using:
// @uniq-f@10357 = std/core/int/max
 fun @lift-maximum@10371[1,0,1,0] : (@uniq-xs@10355 : (std/core/types/list :: V -> V)<std/core/types/int>, @uniq-z@10356 : std/core/types/int) -> std/core/types/int;
// Returns the largest element of a list of integers (or `default` (=`0`) for the empty list)
pub  fun maximum[527,9,527,15] : (xs : (std/core/types/list :: V -> V)<std/core/types/int>, default : (std/core/types/@optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Split a string into a list of lines
pub  fun lines[534,9,534,13] : (s : std/core/types/string) -> (std/core/types/list :: V -> V)<std/core/types/string>;
// Join a list of strings with newlines
pub  fun unlines[538,9,538,15] : (xs : (std/core/types/list :: V -> V)<std/core/types/string>) -> std/core/types/string;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
specialize "__*"  fun (==) // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/True;
          ((@skip std/core/types/Cons((@pat@7: a) : a, (@pat@8: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@6: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/False;
        });
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/(@unroll-x@10001==)<a>(xs, ys, @implicit/(==));
    });
  };
recursive specialize "*__"  fun @lift-flatmap@4959 // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (a) -> (e :: E) (std/core/types/list :: V -> V)<b>, ys: (std/core/types/list :: V -> V)<b>, zs: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Cons((y: b) : b, (yy: (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b> ) as @pat: ((std/core/types/list :: V -> V)<b>))
         -> std/core/types/Cons<b>(y, (std/core/list/@lift-flatmap@4959<a,b,(e :: E)>(f, yy, zs)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<b> ) as @pat@0: ((std/core/types/list :: V -> V)<b>))
         -> (match (zs) {
          ((std/core/types/Cons((z: a) : a, (zz: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
             -> val ys@1@10132[1,0,1,0] : (std/core/types/list :: V -> V)<b>
                      = f(z);
            std/core/list/@lift-flatmap@4959<a,b,(e :: E)>(f, ys@1@10132, zz);
          ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Nil<b>;
        });
    });
  };
specialize "*__"  fun @lift-map-indexed-peek@4951 // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed-peek@4951@10013<a,b,(e :: E)>(f, ys, i);
    });
  };
specialize "*__"  fun @lift-map-indexed@4949 // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed@4949@10011<a,b,(e :: E)>(f, ys, i);
    });
  };
specialize "*_"  fun @lift-map-peek@4950 // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-peek@4950@10012<a,b,(e :: E)>(f, ys);
    });
  };
specialize "*__"  fun @lift-span@4957 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(predicate: (a) -> (e :: E) std/core/types/bool, ys: (std/core/types/list :: V -> V)<a>, acc: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs: (std/core/types/list :: V -> V)<a>){
            (match (xs) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs);
            });
          }))(acc)), ys);
      (@pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-span@4957@10025<a,(e :: E)>(predicate, ys, acc);
    });
  };
specialize "*___"  fun @lift-zipwith-indexed@4953 // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-zipwith-indexed@4953@10021<a,b,c,(e :: E)>(f, i, xs, ys);
    });
  };
recursive specialize "_*"  fun @unroll-all@10030 // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/list/@unroll-all@10030<a,(e :: E)>(xx, predicate);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/False;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
    });
  };
recursive specialize "_*"  fun @unroll-any@10031 // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/True;
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/list/@unroll-any@10031<a,(e :: E)>(xx, predicate);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
recursive specialize "__*"  fun @unroll-cmp@10002 // inline size: 6
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/cmp: (a, a) -> std/core/types/order){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Gt;
          ((@skip std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
             -> (match ((@implicit/cmp(x, y))) {
              ((std/core/types/Eq() : std/core/types/order ) as @pat@2: std/core/types/order)
                 -> std/core/list/@unroll-cmp@10002<a>(xx, yy, @implicit/cmp);
              (lg: std/core/types/order)
                 -> lg;
            });
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@3: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Eq;
          ((@skip std/core/types/Cons((@pat@6: a) : a, (@pat@7: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Lt;
        });
    });
  };
recursive specialize "_*"  fun @unroll-drop-while@10006 // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/list/@unroll-drop-while@10006<a,(e :: E)>(xx, predicate);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> xs;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "_*"  fun @unroll-filter-map@10008 // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/list/@unroll-filter-map@10008<a,b,(e :: E)>(xx, pred);
          ((@skip std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat@2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Cons<b>(y, (std/core/list/@unroll-filter-map@10008<a,b,(e :: E)>(xx, pred)));
        });
    });
  };
recursive specialize "_*"  fun @unroll-filter@10007 // inline size: 6
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/Cons<a>(x, (std/core/list/@unroll-filter@10007<a,(e :: E)>(xx, pred)));
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/list/@unroll-filter@10007<a,(e :: E)>(xx, pred);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "_*"  fun @unroll-flatmap-maybe@10027 // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((f(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat@0: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Cons<b>(y, (std/core/list/@unroll-flatmap-maybe@10027<a,b,(e :: E)>(xx, f)));
          ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/list/@unroll-flatmap-maybe@10027<a,b,(e :: E)>(xx, f);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "__*"  fun @unroll-foldl@10005 // inline size: 3
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, z: b, f: (b, a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foldl@10005<a,b,(e :: E)>(xx, (f(z, x)), f);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> z;
    });
  };
recursive specialize "_*"  fun @unroll-foreach-while@10009 // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/list/@unroll-foreach-while@10009<a,b,(e :: E)>(xx, action);
          (just: ((std/core/types/maybe :: V -> V)<b>))
             -> just;
        });
    });
  };
recursive specialize "_*"  fun @unroll-foreach@10016 // inline size: 3
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) ()){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> val _[374,21,374,29] : ()
                  = action(x);
        std/core/list/@unroll-foreach@10016<a,(e :: E)>(xx, action);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Unit;
    });
  };
recursive specialize "_*_"  fun @unroll-index-of-acc@10015 // inline size: 7
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, idx: std/core/types/int){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> idx;
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/list/@unroll-index-of-acc@10015<a,(e :: E)>(xx, pred, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x@0: std/core/types/int, y: std/core/types/int){
                (std/core/int/int-add(x@0, y));
              }))(idx, 1)));
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> -1;
    });
  };
recursive specialize "*__"  fun @unroll-lift-map-indexed-peek@4951@10013 // inline size: 7
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> val i@0@10077[1,0,1,0] : std/core/types/int
                  = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y@0: std/core/types/int){
                    (std/core/int/int-add(x, y@0));
                  }))(i, 1);
        std/core/types/Cons<b>((f(i, y, yy)), (std/core/list/@unroll-lift-map-indexed-peek@4951@10013<a,b,(e :: E)>(f, yy, i@0@10077)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "*__"  fun @unroll-lift-map-indexed@4949@10011 // inline size: 7
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> val i@0@10069[1,0,1,0] : std/core/types/int
                  = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y@0: std/core/types/int){
                    (std/core/int/int-add(x, y@0));
                  }))(i, 1);
        std/core/types/Cons<b>((f(i, y)), (std/core/list/@unroll-lift-map-indexed@4949@10011<a,b,(e :: E)>(f, yy, i@0@10069)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "*_"  fun @unroll-lift-map-peek@4950@10012 // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Cons<b>((f(y, yy)), (std/core/list/@unroll-lift-map-peek@4950@10012<a,b,(e :: E)>(f, yy)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "*__"  fun @unroll-lift-span@4957@10025 // inline size: 15
  = forall<a,(e :: E)> fn<(e :: E)>(predicate: (a) -> (e :: E) std/core/types/bool, ys: (std/core/types/list :: V -> V)<a>, acc: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(y))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/list/@unroll-lift-span@4957@10025<a,(e :: E)>(predicate, yy, (std/core/types/Cons<a>(y, acc)));
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs: (std/core/types/list :: V -> V)<a>){
                (match (xs) {
                  ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0: ((std/core/types/list :: V -> V)<a>))
                     -> std/core/types/Nil<a>;
                  (@pat@2: ((std/core/types/list :: V -> V)<a>))
                     -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs);
                });
              }))(acc)), ys);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs@1: (std/core/types/list :: V -> V)<a>){
            (match (xs@1) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@1: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat@3: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs@1);
            });
          }))(acc)), ys);
    });
  };
recursive specialize "*___"  fun @unroll-lift-zipwith-indexed@4953@10021 // inline size: 8
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Cons((y: b) : b, (yy: (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b> ) as @pat@0: ((std/core/types/list :: V -> V)<b>))
             -> val i@0@10105[1,0,1,0] : std/core/types/int
                      = std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x@0: std/core/types/int, y@0: std/core/types/int){
                        (std/core/int/int-add(x@0, y@0));
                      }))(i, 1);
            std/core/types/Cons<c>((f(i, x, y)), (std/core/list/@unroll-lift-zipwith-indexed@4953@10021<a,b,c,(e :: E)>(f, i@0@10105, xx, yy)));
          ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<b> ) as @pat@1: ((std/core/types/list :: V -> V)<b>))
             -> std/core/types/Nil<c>;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
    });
  };
recursive specialize "_*"  fun @unroll-map-while@10017 // inline size: 5
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as @pat@1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Cons<b>(y, (std/core/list/@unroll-map-while@10017<a,b,(e :: E)>(xx, action)));
          ((@skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as @pat@2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/types/Nil<b>;
        });
    });
  };
recursive specialize "_*"  fun @unroll-map@10010 // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Cons<b>((f(x)), (std/core/list/@unroll-map@10010<a,b,(e :: E)>(xx, f)));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
    });
  };
recursive specialize "_*__" borrow "_^__"  fun @unroll-partition-acc@10014 // inline size: 24
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, acc1: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1, (std/core/types/Nil<a>))), (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2, (std/core/types/Nil<a>))));
      ((@skip std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> val @cctx-x2361[1,0,1,0] : (std/core/types/list :: V -> V)<a>
                  = std/core/types/Cons<a>(x, (std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> (std/core/types/list :: V -> V)<a>,() -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/@cctx-hole-create<(std/core/types/list :: V -> V)<a>>))()));
                val @cctx-x2362[1,0,1,0] : (std/core/types/@field-addr :: V -> V)<(std/core/types/list :: V -> V)<a>>
                  = std/core/types/@field-addr-of<(std/core/types/list :: V -> V)<a>>(@cctx-x2361, "(\x22std/core/types\x22,\x22\x22,\x22Cons\x22)", "(\x22\x22,\x22\x22,\x22tail\x22)");
            std/core/list/@unroll-partition-acc@10014<a,(e :: E)>(xx, pred, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>,(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>>((std/core/types/#cctx/(++)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1, (std/core/types/@cctx-create<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>(@cctx-x2361, @cctx-x2362)))), acc2);
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@2: std/core/types/bool)
             -> val @cctx-x2404[1,0,1,0] : (std/core/types/list :: V -> V)<a>
                  = std/core/types/Cons<a>(x, (std/core/types/@open<(std/core/types/total :: E),(e :: E),() -> (std/core/types/list :: V -> V)<a>,() -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/@cctx-hole-create<(std/core/types/list :: V -> V)<a>>))()));
                val @cctx-x2405[1,0,1,0] : (std/core/types/@field-addr :: V -> V)<(std/core/types/list :: V -> V)<a>>
                  = std/core/types/@field-addr-of<(std/core/types/list :: V -> V)<a>>(@cctx-x2404, "(\x22std/core/types\x22,\x22\x22,\x22Cons\x22)", "(\x22\x22,\x22\x22,\x22tail\x22)");
            std/core/list/@unroll-partition-acc@10014<a,(e :: E)>(xx, pred, acc1, (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>,(c1 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, c2 : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>) -> (e :: E) (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>>((std/core/types/#cctx/(++)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2, (std/core/types/@cctx-create<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>(@cctx-x2404, @cctx-x2405)))));
        });
    });
  };
recursive specialize "_*"  fun @unroll-take-while@10026 // inline size: 5
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
             -> std/core/types/Cons<a>(x, (std/core/list/@unroll-take-while@10026<a,(e :: E)>(xx, predicate)));
          ((@skip std/core/types/False() : std/core/types/bool ) as @pat@1: std/core/types/bool)
             -> std/core/types/Nil<a>;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "__*"  fun (@unroll-x@10001==) // inline size: 6
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/False;
          ((@skip std/core/types/Cons((y: a) : a, (yy: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
             -> (match ((@implicit/(==)(x, y))) {
              ((std/core/types/True() : std/core/types/bool ) as @pat@2: std/core/types/bool)
                 -> std/core/list/(@unroll-x@10001==)<a>(xx, yy, @implicit/(==));
              (@pat@3: std/core/types/bool)
                 -> std/core/types/False;
            });
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/True;
          ((@skip std/core/types/Cons((@pat@7: a) : a, (@pat@8: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@6: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/False;
        });
    });
  };
recursive specialize "__*"  fun @unroll-zipwith@10020 // inline size: 5
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Cons((y: b) : b, (yy: (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b>) : (std/core/types/list :: V -> V)<b> ) as @pat@0: ((std/core/types/list :: V -> V)<b>))
             -> std/core/types/Cons<c>((f(x, y)), (std/core/list/@unroll-zipwith@10020<a,b,c,(e :: E)>(xx, yy, f)));
          ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<b> ) as @pat@1: ((std/core/types/list :: V -> V)<b>))
             -> std/core/types/Nil<c>;
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
    });
  };
specialize "_*"  fun all // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-all@10030<a,(e :: E)>(xs, predicate);
    });
  };
specialize "_*"  fun any // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-any@10031<a,(e :: E)>(xs, predicate);
    });
  };
specialize "__*"  fun cmp // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/cmp: (a, a) -> std/core/types/order){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@3: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Eq;
          ((@skip std/core/types/Cons((@pat@6: a) : a, (@pat@7: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Lt;
        });
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-cmp@10002<a>(xs, ys, @implicit/cmp);
    });
  };
specialize "_*"  fun drop-while // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-drop-while@10006<a,(e :: E)>(xs, predicate);
    });
  };
specialize "_*"  fun filter // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-filter@10007<a,(e :: E)>(xs, pred);
    });
  };
specialize "_*"  fun filter-map // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-filter-map@10008<a,b,(e :: E)>(xs, pred);
    });
  };
specialize "_*"  fun find // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foreach-while@10009<a,a,(e :: E)>(xs, (fn<(e :: E)>(x: a){
            (match ((pred(x))) {
              ((std/core/types/True() : std/core/types/bool ) as @pat@1: std/core/types/bool)
                 -> std/core/types/Just<a>(x);
              ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@0: std/core/types/bool)
                 -> std/core/types/Nothing<a>;
            });
          }));
    });
  };
specialize "_*"  fun find-maybe // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foreach-while@10009<a,b,(e :: E)>(xs, pred);
    });
  };
specialize "_*"  fun flatmap // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/list :: V -> V)<b>){
    std/core/list/@lift-flatmap@4959<a,b,(e :: E)>(f, (std/core/types/Nil<b>), xs);
  };
specialize "_*"  fun flatmap-maybe // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-flatmap-maybe@10027<a,b,(e :: E)>(xs, f);
    });
  };
specialize "__*"  fun foldl // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, z: b, f: (b, a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> z;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foldl@10005<a,b,(e :: E)>(xs, z, f);
    });
  };
specialize "_*"  fun foldl1 // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xs: (std/core/types/list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (xx) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
             -> x;
          (@pat@1: ((std/core/types/list :: V -> V)<a>))
             -> std/core/list/@unroll-foldl@10005<a,a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xx, x, f);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a>((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(message: std/core/types/string, info: (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>){
          (std/core/hnd/@perform1<std/core/exn/exception,a,(std/core/exn/exn :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(std/core/exn/exn :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(std/core/exn/exn :: (E, V) -> V)>>((std/core/hnd/@evv-at<(std/core/exn/exn :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e1 :: E),b> std/core/exn/@select-throw-exn<a,(e1 :: E),b>), (std/core/exn/Exception(message, (match (info) {
                ((std/core/types/@Optional((@uniq-info@473: std/core/exn/exception-info) : std/core/exn/exception-info) : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info> ) as @pat@2: ((std/core/types/@optional :: V -> V)<std/core/exn/exception-info>))
                   -> @uniq-info@473;
                ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info> ) as @pat@0@1: ((std/core/types/@optional :: V -> V)<std/core/exn/exception-info>))
                   -> std/core/exn/ExnError;
              })))));
        }))("unexpected Nil in std/core/foldl1", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
specialize "__*"  fun foldr // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    val xs@0@10042[1,0,1,0] : (std/core/types/list :: V -> V)<a>
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs@1: (std/core/types/list :: V -> V)<a>){
            (match (xs@1) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs@1);
            });
          }))(xs);
    (match (xs@0@10042) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0: ((std/core/types/list :: V -> V)<a>))
         -> z;
      (@pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foldl@10005<a,b,(e :: E)>(xs@0@10042, z, (fn<(e :: E)>(x: b, y: a){
            (f(y, x));
          }));
    });
  };
specialize "_*"  fun foldr1 // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xs: (std/core/types/list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a){
    val xs@0@10050[1,0,1,0] : (std/core/types/list :: V -> V)<a>
          = std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> (std/core/types/list :: V -> V)<a>>((fn(xs@2: (std/core/types/list :: V -> V)<a>){
            (match (xs@2) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs@2);
            });
          }))(xs);
    (match (xs@0@10050) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> (match (xx) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0: ((std/core/types/list :: V -> V)<a>))
             -> x;
          (@pat@1@0: ((std/core/types/list :: V -> V)<a>))
             -> std/core/list/@unroll-foldl@10005<a,a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xx, x, f);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a>((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(message: std/core/types/string, info: (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>){
          (std/core/hnd/@perform1<std/core/exn/exception,a,(std/core/exn/exn :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(std/core/exn/exn :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(std/core/exn/exn :: (E, V) -> V)>>((std/core/hnd/@evv-at<(std/core/exn/exn :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e1 :: E),b> std/core/exn/@select-throw-exn<a,(e1 :: E),b>), (std/core/exn/Exception(message, (match (info) {
                ((std/core/types/@Optional((@uniq-info@473: std/core/exn/exception-info) : std/core/exn/exception-info) : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info> ) as @pat@2: ((std/core/types/@optional :: V -> V)<std/core/exn/exception-info>))
                   -> @uniq-info@473;
                ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info> ) as @pat@0@1: ((std/core/types/@optional :: V -> V)<std/core/exn/exception-info>))
                   -> std/core/exn/ExnError;
              })))));
        }))("unexpected Nil in std/core/foldl1", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
specialize "_*"  fun foreach // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) ()){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Unit;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foreach@10016<a,(e :: E)>(xs, action);
    });
  };
specialize "_*"  fun foreach-indexed // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (std/core/types/int, a) -> (e :: E) ()){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (() -> (e :: E) ()),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (e :: E) (() -> (e :: E) ())>((std/core/types/unsafe-no-local-cast<(),(e :: E)>))((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(){
      std/core/hnd/local-var<std/core/types/int,(),(e :: E),(h :: H)>(0, (fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(i: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>){
          (match (xs) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
               -> std/core/types/Unit;
            (@pat: ((std/core/types/list :: V -> V)<a>))
               -> std/core/list/@unroll-foreach@10016<a,<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(xs, (fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(x: a){
                  val j[400,9,400,9] : std/core/types/int
                    = (std/core/types/local-get<std/core/types/int,(h :: H),(e :: E)>(i));
                  val _[401,5,401,15] : ()
                    = (std/core/hnd/@mask-builtin<(),(e :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>((fn<(e :: E)>(){
                      (action(j, x));
                    })));
                  (std/core/types/local-set<std/core/types/int,(e :: E),(h :: H)>(i, (std/core/types/@open<(std/core/types/total :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> std/core/types/int>((fn(x@0: std/core/types/int, y: std/core/types/int){
                      (std/core/int/int-add(x@0, y));
                    }))((std/core/types/local-get<std/core/types/int,(h :: H),(e :: E)>(i)), 1))));
                }));
          });
        }));
    }))();
  };
specialize "_*"  fun foreach-while // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foreach-while@10009<a,b,(e :: E)>(xs, action);
    });
  };
specialize "_*"  fun index-of // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> -1;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-index-of-acc@10015<a,(e :: E)>(xs, pred, 0);
    });
  };
specialize "_*_"  fun index-of-acc // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, idx: std/core/types/int){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> -1;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-index-of-acc@10015<a,(e :: E)>(xs, pred, idx);
    });
  };
specialize "_*"  fun lookup // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<(a, b)>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b)> ) as @pat: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/types/Nothing<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/list/@unroll-foreach-while@10009<(a, b),b,(e :: E)>(xs, (fn<(e :: E)>(kv: (a, b)){
            (match ((pred((std/core/types/@open<(std/core/types/total :: E),(e :: E),(tuple2 : (a, b)) -> a,(tuple2 : (a, b)) -> (e :: E) a>((fn(tuple2: (a, b)){
              (match (tuple2) {
                ((@skip std/core/types/Tuple2((@x: a) : a, (@pat@0@0: b) : b) : (a, b) ) as @pat@1: (a, b))
                   -> @x;
              });
            }))(kv))))) {
              ((std/core/types/True() : std/core/types/bool ) as @pat@2: std/core/types/bool)
                 -> std/core/types/Just<b>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(tuple2 : (a, b)) -> b,(tuple2 : (a, b)) -> (e :: E) b>((fn(tuple2@0: (a, b)){
                  (match (tuple2@0) {
                    ((@skip std/core/types/Tuple2((@pat@0@1: a) : a, (@x@0: b) : b) : (a, b) ) as @pat@3: (a, b))
                       -> @x@0;
                  });
                }))(kv)));
              ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@2: std/core/types/bool)
                 -> std/core/types/Nothing<b>;
            });
          }));
    });
  };
specialize "_*"  fun map // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-map@10010<a,b,(e :: E)>(xs, f);
    });
  };
specialize "_*"  fun map-indexed // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed@4949@10011<a,b,(e :: E)>(f, xs, 0);
    });
  };
specialize "_*"  fun map-indexed-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed-peek@4951@10013<a,b,(e :: E)>(f, xs, 0);
    });
  };
specialize "_*"  fun map-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-peek@4950@10012<a,b,(e :: E)>(f, xs);
    });
  };
specialize "_*"  fun map-while // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-map-while@10017<a,b,(e :: E)>(xs, action);
    });
  };
specialize "_*" borrow "_^"  fun partition // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    val acc1@10086[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>();
    val acc2@10087[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>();
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1@10086, (std/core/types/Nil<a>))), (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2@10087, (std/core/types/Nil<a>))));
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-partition-acc@10014<a,(e :: E)>(xs, pred, acc1@10086, acc2@10087);
    });
  };
specialize "_*__" borrow "_^__"  fun partition-acc // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, acc1: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1, (std/core/types/Nil<a>))), (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2, (std/core/types/Nil<a>))));
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-partition-acc@10014<a,(e :: E)>(xs, pred, acc1, acc2);
    });
  };
specialize "_*"  fun remove // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-filter@10007<a,(e :: E)>(xs, (fn<(e :: E)>(x: a){
            (std/core/types/@open<(std/core/types/total :: E),(e :: E),(b : std/core/types/bool) -> std/core/types/bool,(b : std/core/types/bool) -> (e :: E) std/core/types/bool>((fn(b: std/core/types/bool){
              (match (b) {
                ((std/core/types/True() : std/core/types/bool ) as @pat@0: std/core/types/bool)
                   -> std/core/types/False;
                ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0@0: std/core/types/bool)
                   -> std/core/types/True;
              });
            }))((pred(x))));
          }));
    });
  };
specialize "_*"  fun show // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, @implicit/show: (a) -> (e :: E) std/core/types/string){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/string, y : std/core/types/string) -> std/core/types/string,(x : std/core/types/string, y : std/core/types/string) -> (e :: E) std/core/types/string>(std/core/types/(++))("[", (std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/string, y : std/core/types/string) -> std/core/types/string,(x : std/core/types/string, y : std/core/types/string) -> (e :: E) std/core/types/string>(std/core/types/(++))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string,(xs : (std/core/types/list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> (e :: E) std/core/types/string>((fn(xs@0: (std/core/types/list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
          (match (xs@0) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> "";
            ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> x;
            ((std/core/types/Cons((x@0: std/core/types/string) : std/core/types/string, ((std/core/types/Cons((y: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@4: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@3: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
               | std/core/string/(==)(sep, "") -> std/core/types/(++)(x@0, y);
            (@pat@5: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> std/core/string/#vectorsep/join((std/core/vector/unvlist<std/core/types/string>(xs@0)), sep);
          });
        }))((match (xs) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0: ((std/core/types/list :: V -> V)<a>))
               -> std/core/types/Nil<std/core/types/string>;
            (@pat@6: ((std/core/types/list :: V -> V)<a>))
               -> std/core/list/@unroll-map@10010<a,std/core/types/string,(e :: E)>(xs, @implicit/show);
          }), ",")), "]")));
  };
specialize "_*"  fun show-list // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, show-elem: (a) -> (e :: E) std/core/types/string){
    std/core/list/show<a,(e :: E)>(xs, show-elem);
  };
specialize "_*"  fun span // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs@0: (std/core/types/list :: V -> V)<a>){
            (match (xs@0) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs@0);
            });
          }))((std/core/types/Nil<a>))), xs);
      (@pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-span@4957@10025<a,(e :: E)>(predicate, xs, (std/core/types/Nil<a>));
    });
  };
specialize "_*"  fun take-while // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-take-while@10026<a,(e :: E)>(xs, predicate);
    });
  };
specialize "__*"  fun zipwith // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-zipwith@10020<a,b,c,(e :: E)>(xs, ys, f);
    });
  };
specialize "__*"  fun zipwith-indexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs0: (std/core/types/list :: V -> V)<a>, ys0: (std/core/types/list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    (match (xs0) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-zipwith-indexed@4953@10021<a,b,c,(e :: E)>(f, 0, xs0, ys0);
    });
  };
recursive specialize "__*"  fun function/list // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/int/(<=))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/Cons<a>((f(lo)), (std/core/list/#function/list<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/undiv/pretend-decreasing<std/core/types/int>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
              (std/core/int/int-add(i, 1));
            }))(lo)))), hi, f)));
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/core/types/Nil<a>;
    });
  };
recursive specialize "___*"  fun stridefunction/list // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, stride: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/int/(<=))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as @pat: std/core/types/bool)
         -> std/core/types/Cons<a>((f(lo)), (std/core/list/#stridefunction/list<a,(e :: E)>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/undiv/pretend-decreasing<std/core/types/int>))((std/core/types/@open<(std/core/types/total :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y: std/core/types/int){
              (std/core/int/int-add(x, y));
            }))(lo, stride)))), hi, stride, f)));
      ((@skip std/core/types/False() : std/core/types/bool ) as @pat@0: std/core/types/bool)
         -> std/core/types/Nil<a>;
    });
  };
specialize "_*"  fun string/map // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, f: (std/core/types/char) -> (e :: E) std/core/types/char){
    val xs@10066[1,0,1,0] : (std/core/types/list :: V -> V)<std/core/types/char>
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(s : std/core/types/string) -> (std/core/types/list :: V -> V)<std/core/types/char>,(s : std/core/types/string) -> (e :: E) (std/core/types/list :: V -> V)<std/core/types/char>>(std/core/string/list)(s);
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> std/core/types/string,(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> (e :: E) std/core/types/string>(std/core/string/#listchar/string)((match (xs@10066) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/char> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/char>))
         -> std/core/types/Nil<std/core/types/char>;
      (@pat: ((std/core/types/list :: V -> V)<std/core/types/char>))
         -> std/core/list/@unroll-map@10010<std/core/types/char,std/core/types/char,(e :: E)>(xs@10066, f);
    }));
  };
 fun head // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (@pat@0: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
    });
  };
 fun default/head // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, default: a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (@pat@0: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> x;
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> default;
    });
  };
 fun tail // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Cons((@pat@0: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> xx;
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
 fun is-empty // inline size: 1
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
 fun single // inline size: 1
  = forall<a> fn(x: a){
    std/core/types/Cons<a>(x, (std/core/types/Nil<a>));
  };
inline  fun @lift-length@4947 // inline size: 2
  = forall<a> fn(ys: (std/core/types/list :: V -> V)<a>, acc: std/core/types/int){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> acc;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-length@4947@10000<a>(ys, acc);
    });
  };
 fun length // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> 0;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-length@4947@10000<a>(xs, 0);
    });
  };
inline  fun (==) // inline size: 3
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/(==): (a, a) -> std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/True;
          ((@skip std/core/types/Cons((@pat@7: a) : a, (@pat@8: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@6: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/False;
        });
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/(@unroll-x@10001==)<a>(xs, ys, @implicit/(==));
    });
  };
inline  fun cmp // inline size: 3
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>, @implicit/cmp: (a, a) -> std/core/types/order){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@3: ((std/core/types/list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Eq;
          ((@skip std/core/types/Cons((@pat@6: a) : a, (@pat@7: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@5: ((std/core/types/list :: V -> V)<a>))
             -> std/core/types/Lt;
        });
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-cmp@10002<a>(xs, ys, @implicit/cmp);
    });
  };
inline  fun @lift-reverse-append@4948 // inline size: 2
  = forall<a> fn(acc: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> acc;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>(acc, ys);
    });
  };
 fun reverse-append // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, tl: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> tl;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>(tl, xs);
    });
  };
 fun reverse // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs);
    });
  };
inline  fun append // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> ys;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-append@10004<a>(xs, ys);
    });
  };
 fun (++) // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<a>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> ys;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-append@10004<a>(xs, ys);
    });
  };
inline  fun foldl // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, z: b, f: (b, a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> z;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foldl@10005<a,b,(e :: E)>(xs, z, f);
    });
  };
 fun foldr // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    val xs@0@10042[1,0,1,0] : (std/core/types/list :: V -> V)<a>
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs@1: (std/core/types/list :: V -> V)<a>){
            (match (xs@1) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs@1);
            });
          }))(xs);
    (match (xs@0@10042) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0: ((std/core/types/list :: V -> V)<a>))
         -> z;
      (@pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@lift-foldr@10363<a,b,(e :: E)>(f, xs@0@10042, z);
    });
  };
 fun foldl1 // inline size: 12
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xs: (std/core/types/list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> (match (xx) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
             -> x;
          (@pat@1: ((std/core/types/list :: V -> V)<a>))
             -> std/core/list/@unroll-foldl@10005<a,a,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>>(xx, x, f);
        });
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/@open<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> a,(message : std/core/types/string, info : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>|(e :: E)> a>((fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>(message: std/core/types/string, info: (std/core/types/@optional :: V -> V)<std/core/exn/exception-info>){
          (std/core/hnd/@perform1<std/core/exn/exception,a,(std/core/exn/exn :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(std/core/exn/exn :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(std/core/exn/exn :: (E, V) -> V)>>((std/core/hnd/@evv-at<(std/core/exn/exn :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), (forall<(e1 :: E),b> std/core/exn/@select-throw-exn<a,(e1 :: E),b>), (std/core/exn/Exception(message, (match (info) {
                ((std/core/types/@Optional((@uniq-info@473: std/core/exn/exception-info) : std/core/exn/exception-info) : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info> ) as @pat@2: ((std/core/types/@optional :: V -> V)<std/core/exn/exception-info>))
                   -> @uniq-info@473;
                ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/exn/exception-info> ) as @pat@0@1: ((std/core/types/@optional :: V -> V)<std/core/exn/exception-info>))
                   -> std/core/exn/ExnError;
              })))));
        }))("unexpected Nil in std/core/foldl1", (std/core/types/@None<std/core/exn/exception-info>));
    });
  };
 fun split // inline size: 3
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, n: std/core/types/int){
    std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/list/take<a>(xs, n)), (std/core/list/drop<a>(xs, n)));
  };
inline  fun drop-while // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-drop-while@10006<a,(e :: E)>(xs, predicate);
    });
  };
inline  fun filter // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-filter@10007<a,(e :: E)>(xs, pred);
    });
  };
inline  fun filter-map // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-filter-map@10008<a,b,(e :: E)>(xs, pred);
    });
  };
inline  fun foreach-while // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foreach-while@10009<a,b,(e :: E)>(xs, action);
    });
  };
 fun find // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@lift-find@10364<a,(e :: E)>(pred, xs);
    });
  };
 fun find-maybe // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foreach-while@10009<a,b,(e :: E)>(xs, pred);
    });
  };
 fun maybe/list // inline size: 2
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as @pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      ((@skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as @pat@0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Cons<a>(x, (std/core/types/Nil<a>));
    });
  };
inline  fun map // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-map@10010<a,b,(e :: E)>(xs, f);
    });
  };
 fun char/list // inline size: 5
  = fn(lo: std/core/types/char, hi: std/core/types/char){
    val xs@10062[1,0,1,0] : (std/core/types/list :: V -> V)<std/core/types/int>
          = std/core/list/list((std/core/char/int(lo)), (std/core/char/int(hi)));
    match (xs@10062) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> std/core/types/Nil<std/core/types/char>;
      (@pat: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> std/core/list/#char/@lift-list@10365(xs@10062);
    };
  };
 fun string/map // inline size: 6
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, f: (std/core/types/char) -> (e :: E) std/core/types/char){
    val xs@10066[1,0,1,0] : (std/core/types/list :: V -> V)<std/core/types/char>
          = std/core/types/@open<(std/core/types/total :: E),(e :: E),(s : std/core/types/string) -> (std/core/types/list :: V -> V)<std/core/types/char>,(s : std/core/types/string) -> (e :: E) (std/core/types/list :: V -> V)<std/core/types/char>>(std/core/string/list)(s);
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> std/core/types/string,(cs : (std/core/types/list :: V -> V)<std/core/types/char>) -> (e :: E) std/core/types/string>(std/core/string/#listchar/string)((match (xs@10066) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/char> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/char>))
         -> std/core/types/Nil<std/core/types/char>;
      (@pat: ((std/core/types/list :: V -> V)<std/core/types/char>))
         -> std/core/list/@unroll-map@10010<std/core/types/char,std/core/types/char,(e :: E)>(xs@10066, f);
    }));
  };
inline  fun @lift-map-indexed@4949 // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed@4949@10011<a,b,(e :: E)>(f, ys, i);
    });
  };
 fun map-indexed // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed@4949@10011<a,b,(e :: E)>(f, xs, 0);
    });
  };
inline  fun @lift-map-peek@4950 // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-peek@4950@10012<a,b,(e :: E)>(f, ys);
    });
  };
 fun map-peek // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-peek@4950@10012<a,b,(e :: E)>(f, xs);
    });
  };
inline  fun @lift-map-indexed-peek@4951 // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b, ys: (std/core/types/list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed-peek@4951@10013<a,b,(e :: E)>(f, ys, i);
    });
  };
 fun map-indexed-peek // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (idx : std/core/types/int, value : a, rest : (std/core/types/list :: V -> V)<a>) -> (e :: E) b){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-map-indexed-peek@4951@10013<a,b,(e :: E)>(f, xs, 0);
    });
  };
 fun remove // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@lift-remove@10366<a,(e :: E)>(pred, xs);
    });
  };
inline borrow "_^__"  fun partition-acc // inline size: 7
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, acc1: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>, acc2: (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1, (std/core/types/Nil<a>))), (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2, (std/core/types/Nil<a>))));
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-partition-acc@10014<a,(e :: E)>(xs, pred, acc1, acc2);
    });
  };
borrow "_^"  fun partition // inline size: 9
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    val acc1@10086[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>();
    val acc2@10087[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>();
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc1@10086, (std/core/types/Nil<a>))), (std/core/types/@open<(std/core/types/total :: E),(e :: E),(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(c : (std/core/types/cctx :: (V, V) -> V)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>, x : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>))(acc2@10087, (std/core/types/Nil<a>))));
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-partition-acc@10014<a,(e :: E)>(xs, pred, acc1@10086, acc2@10087);
    });
  };
 fun lookup // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<(a, b)>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b)> ) as @pat: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/types/Nothing<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/list/@lift-lookup@10367<a,b,(e :: E)>(pred, xs);
    });
  };
inline  fun index-of-acc // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, idx: std/core/types/int){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> -1;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-index-of-acc@10015<a,(e :: E)>(xs, pred, idx);
    });
  };
 fun index-of // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> -1;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-index-of-acc@10015<a,(e :: E)>(xs, pred, 0);
    });
  };
inline  fun foreach // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) ()){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Unit;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-foreach@10016<a,(e :: E)>(xs, action);
    });
  };
inline  fun map-while // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-map-while@10017<a,b,(e :: E)>(xs, action);
    });
  };
 fun foreach-indexed // inline size: 6
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, action: (std/core/types/int, a) -> (e :: E) ()){
    std/core/types/@open<(std/core/types/total :: E),(e :: E),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (() -> (e :: E) ()),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (e :: E) (() -> (e :: E) ())>((std/core/types/unsafe-no-local-cast<(),(e :: E)>))((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(){
      std/core/hnd/local-var<std/core/types/int,(),(e :: E),(h :: H)>(0, (fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(i: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>){
          (match (xs) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
               -> std/core/types/Unit;
            (@pat: ((std/core/types/list :: V -> V)<a>))
               -> std/core/list/@lift-foreach-indexed@10368<(h :: H),a,(e :: E)>(action, i, xs);
          });
        }));
    }))();
  };
inline  fun @lift-intersperse@4952 // inline size: 2
  = forall<a> fn(sep: a, ys: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-intersperse@4952@10018<a>(sep, ys);
    });
  };
 fun intersperse // inline size: 4
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, sep: a){
    (match (xs) {
      ((std/core/types/Cons((x: a) : a, (xx: (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a>) : (std/core/types/list :: V -> V)<a> ) as @pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Cons<a>(x, (match (xx) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
               -> std/core/types/Nil<a>;
            (@pat: ((std/core/types/list :: V -> V)<a>))
               -> std/core/list/@unroll-lift-intersperse@4952@10018<a>(sep, xx);
          }));
      ((@skip std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
    });
  };
 fun join // inline size: 6
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> x;
      ((@skip std/core/types/Cons((x@0: std/core/types/string) : std/core/types/string, ((@skip std/core/types/Cons((y: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@4: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@3: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/types/(++)(x@0, y);
      (@pat@5: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/string/#vector/join((std/core/vector/unvlist<std/core/types/string>(xs)));
    };
  };
 fun joinsep // inline size: 7
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> x;
      ((std/core/types/Cons((x@0: std/core/types/string) : std/core/types/string, ((std/core/types/Cons((y: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@4: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@3: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         | std/core/string/(==)(sep, "") -> std/core/types/(++)(x@0, y);
      (@pat@5: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/string/#vectorsep/join((std/core/vector/unvlist<std/core/types/string>(xs)), sep);
    };
  };
 fun joinsep/join // inline size: 1
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    std/core/list/joinsep(xs, sep);
  };
 fun show-list // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, show-elem: (a) -> (e :: E) std/core/types/string){
    std/core/list/show<a,(e :: E)>(xs, show-elem);
  };
inline  fun zip // inline size: 2
  = forall<a,b> fn(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<(a, b)>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-zip@10019<a,b>(xs, ys);
    });
  };
inline  fun zipwith // inline size: 2
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-zipwith@10020<a,b,c,(e :: E)>(xs, ys, f);
    });
  };
inline  fun @lift-zipwith-indexed@4953 // inline size: 2
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, xs: (std/core/types/list :: V -> V)<a>, ys: (std/core/types/list :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-zipwith-indexed@4953@10021<a,b,c,(e :: E)>(f, i, xs, ys);
    });
  };
 fun zipwith-indexed // inline size: 2
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs0: (std/core/types/list :: V -> V)<a>, ys0: (std/core/types/list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    (match (xs0) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<c>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-zipwith-indexed@4953@10021<a,b,c,(e :: E)>(f, 0, xs0, ys0);
    });
  };
inline  fun @lift-unzip@4954 // inline size: 5
  = forall<a,b,c,d> fn(ys: (std/core/types/list :: V -> V)<(a, b)>, acc1: (std/core/types/cctx :: (V, V) -> V)<c,(std/core/types/list :: V -> V)<a>>, acc2: (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<b>>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b)> ) as @pat@1: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/types/Tuple2<c,d>((std/core/types/#cctx/(++.)<c,(std/core/types/list :: V -> V)<a>>(acc1, (std/core/types/Nil<a>))), (std/core/types/#cctx/(++.)<d,(std/core/types/list :: V -> V)<b>>(acc2, (std/core/types/Nil<b>))));
      (@pat: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/list/@unroll-lift-unzip@4954@10022<a,b,c,d>(ys, acc1, acc2);
    });
  };
 fun unzip // inline size: 7
  = forall<a,b> fn(xs: (std/core/types/list :: V -> V)<(a, b)>){
    val acc1@10160[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>();
    val acc2@10161[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<b>>();
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b)> ) as @pat@1: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>(acc1@10160, (std/core/types/Nil<a>))), (std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<b>>(acc2@10161, (std/core/types/Nil<b>))));
      (@pat: ((std/core/types/list :: V -> V)<(a, b)>))
         -> std/core/list/@unroll-lift-unzip@4954@10022<a,b,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>>(xs, acc1@10160, acc2@10161);
    });
  };
inline  fun @lift-unzip3@4955 // inline size: 6
  = forall<a,b,c,d,a1,b1> fn(ys: (std/core/types/list :: V -> V)<(a, b, c)>, acc1: (std/core/types/cctx :: (V, V) -> V)<d,(std/core/types/list :: V -> V)<a>>, acc2: (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<b>>, acc3: (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<c>>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b, c)> ) as @pat@1: ((std/core/types/list :: V -> V)<(a, b, c)>))
         -> std/core/types/Tuple3<d,a1,b1>((std/core/types/#cctx/(++.)<d,(std/core/types/list :: V -> V)<a>>(acc1, (std/core/types/Nil<a>))), (std/core/types/#cctx/(++.)<a1,(std/core/types/list :: V -> V)<b>>(acc2, (std/core/types/Nil<b>))), (std/core/types/#cctx/(++.)<b1,(std/core/types/list :: V -> V)<c>>(acc3, (std/core/types/Nil<c>))));
      (@pat: ((std/core/types/list :: V -> V)<(a, b, c)>))
         -> std/core/list/@unroll-lift-unzip3@4955@10023<a,b,c,d,a1,b1>(ys, acc1, acc2, acc3);
    });
  };
 fun unzip3 // inline size: 9
  = forall<a,b,c> fn(xs: (std/core/types/list :: V -> V)<(a, b, c)>){
    val acc1@10163[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>();
    val acc2@10164[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<b>>();
    val acc3@10165[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<c>>();
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b, c)> ) as @pat@1: ((std/core/types/list :: V -> V)<(a, b, c)>))
         -> std/core/types/Tuple3<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<c>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>(acc1@10163, (std/core/types/Nil<a>))), (std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<b>>(acc2@10164, (std/core/types/Nil<b>))), (std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<c>,(std/core/types/list :: V -> V)<c>>(acc3@10165, (std/core/types/Nil<c>))));
      (@pat: ((std/core/types/list :: V -> V)<(a, b, c)>))
         -> std/core/list/@unroll-lift-unzip3@4955@10023<a,b,c,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<c>>(xs, acc1@10163, acc2@10164, acc3@10165);
    });
  };
inline  fun @lift-unzip4@4956 // inline size: 7
  = forall<a,b,c,d,a1,b1,c1,d1> fn(ys: (std/core/types/list :: V -> V)<(a, b, c, d)>, acc1: (std/core/types/cctx :: (V, V) -> V)<a1,(std/core/types/list :: V -> V)<a>>, acc2: (std/core/types/cctx :: (V, V) -> V)<b1,(std/core/types/list :: V -> V)<b>>, acc3: (std/core/types/cctx :: (V, V) -> V)<c1,(std/core/types/list :: V -> V)<c>>, acc4: (std/core/types/cctx :: (V, V) -> V)<d1,(std/core/types/list :: V -> V)<d>>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b, c, d)> ) as @pat@1: ((std/core/types/list :: V -> V)<(a, b, c, d)>))
         -> std/core/types/Tuple4<a1,b1,c1,d1>((std/core/types/#cctx/(++.)<a1,(std/core/types/list :: V -> V)<a>>(acc1, (std/core/types/Nil<a>))), (std/core/types/#cctx/(++.)<b1,(std/core/types/list :: V -> V)<b>>(acc2, (std/core/types/Nil<b>))), (std/core/types/#cctx/(++.)<c1,(std/core/types/list :: V -> V)<c>>(acc3, (std/core/types/Nil<c>))), (std/core/types/#cctx/(++.)<d1,(std/core/types/list :: V -> V)<d>>(acc4, (std/core/types/Nil<d>))));
      (@pat: ((std/core/types/list :: V -> V)<(a, b, c, d)>))
         -> std/core/list/@unroll-lift-unzip4@4956@10024<a,b,c,d,a1,b1,c1,d1>(ys, acc1, acc2, acc3, acc4);
    });
  };
 fun unzip4 // inline size: 11
  = forall<a,b,c,d> fn(xs: (std/core/types/list :: V -> V)<(a, b, c, d)>){
    val acc1@10167[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<a>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<a>>();
    val acc2@10168[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<b>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<b>>();
    val acc3@10169[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<c>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<c>>();
    val acc4@10170[1,0,1,0] : (std/core/types/ctx :: V -> V)<(std/core/types/list :: V -> V)<d>>
      = std/core/types/#cctx/empty<(std/core/types/list :: V -> V)<d>>();
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(a, b, c, d)> ) as @pat@1: ((std/core/types/list :: V -> V)<(a, b, c, d)>))
         -> std/core/types/Tuple4<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<c>,(std/core/types/list :: V -> V)<d>>((std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>(acc1@10167, (std/core/types/Nil<a>))), (std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<b>>(acc2@10168, (std/core/types/Nil<b>))), (std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<c>,(std/core/types/list :: V -> V)<c>>(acc3@10169, (std/core/types/Nil<c>))), (std/core/types/#cctx/(++.)<(std/core/types/list :: V -> V)<d>,(std/core/types/list :: V -> V)<d>>(acc4@10170, (std/core/types/Nil<d>))));
      (@pat: ((std/core/types/list :: V -> V)<(a, b, c, d)>))
         -> std/core/list/@unroll-lift-unzip4@4956@10024<a,b,c,d,(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<b>,(std/core/types/list :: V -> V)<c>,(std/core/types/list :: V -> V)<d>>(xs, acc1@10167, acc2@10168, acc3@10169, acc4@10170);
    });
  };
inline  fun @lift-span@4957 // inline size: 7
  = forall<a,(e :: E)> fn<(e :: E)>(predicate: (a) -> (e :: E) std/core/types/bool, ys: (std/core/types/list :: V -> V)<a>, acc: (std/core/types/list :: V -> V)<a>){
    (match (ys) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs: (std/core/types/list :: V -> V)<a>){
            (match (xs) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs);
            });
          }))(acc)), ys);
      (@pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-span@4957@10025<a,(e :: E)>(predicate, ys, acc);
    });
  };
 fun span // inline size: 7
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Tuple2<(std/core/types/list :: V -> V)<a>,(std/core/types/list :: V -> V)<a>>((std/core/types/@open<(std/core/types/total :: E),(e :: E),(xs : (std/core/types/list :: V -> V)<a>) -> (std/core/types/list :: V -> V)<a>,(xs : (std/core/types/list :: V -> V)<a>) -> (e :: E) (std/core/types/list :: V -> V)<a>>((fn(xs@0: (std/core/types/list :: V -> V)<a>){
            (match (xs@0) {
              ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@0: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/types/Nil<a>;
              (@pat: ((std/core/types/list :: V -> V)<a>))
                 -> std/core/list/@unroll-lift-reverse-append@4948@10003<a>((std/core/types/Nil<a>), xs@0);
            });
          }))((std/core/types/Nil<a>))), xs);
      (@pat@1: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-lift-span@4957@10025<a,(e :: E)>(predicate, xs, (std/core/types/Nil<a>));
    });
  };
inline  fun take-while // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-take-while@10026<a,(e :: E)>(xs, predicate);
    });
  };
 fun reverse-join // inline size: 8
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>){
    val xs@0@10125[1,0,1,0] : (std/core/types/list :: V -> V)<std/core/types/string>
          = match (xs) {
            ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> std/core/types/Nil<std/core/types/string>;
            (@pat: ((std/core/types/list :: V -> V)<std/core/types/string>))
               -> std/core/list/@unroll-lift-reverse-append@4948@10003<std/core/types/string>((std/core/types/Nil<std/core/types/string>), xs);
          };
    match (xs@0@10125) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1@0: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@0@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> x;
      ((@skip std/core/types/Cons((x@0: std/core/types/string) : std/core/types/string, ((@skip std/core/types/Cons((y: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@4: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@3: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/types/(++)(x@0, y);
      (@pat@5: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/string/#vector/join((std/core/vector/unvlist<std/core/types/string>(xs@0@10125)));
    };
  };
 fun join-end // inline size: 3
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>, end: std/core/types/string){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      (@pat@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/types/(++)((std/core/list/joinsep(xs, end)), end);
    };
  };
 fun concat // inline size: 1
  = forall<a> fn(xss: (std/core/types/list :: V -> V)<(std/core/types/list :: V -> V)<a>>){
    std/core/list/@lift-concat@4958<a>((std/core/types/Nil<a>), xss);
  };
 fun flatmap // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/list :: V -> V)<b>){
    std/core/list/@lift-flatmap@4959<a,b,(e :: E)>(f, (std/core/types/Nil<b>), xs);
  };
inline  fun flatmap-maybe // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nil<b>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-flatmap-maybe@10027<a,b,(e :: E)>(xs, f);
    });
  };
inline  fun concat-maybe // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>> ) as @pat@2: ((std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>))
         -> std/core/types/Nil<a>;
      (@pat: ((std/core/types/list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>))
         -> std/core/list/@unroll-concat-maybe@10028<a>(xs);
    });
  };
inline  fun @index // inline size: 2
  = forall<a> fn(xs: (std/core/types/list :: V -> V)<a>, n: std/core/types/int){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@4: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-index@10029<a>(xs, n);
    });
  };
inline  fun all // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/True;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-all@10030<a,(e :: E)>(xs, predicate);
    });
  };
inline  fun any // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (std/core/types/list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<a> ) as @pat@2: ((std/core/types/list :: V -> V)<a>))
         -> std/core/types/False;
      (@pat: ((std/core/types/list :: V -> V)<a>))
         -> std/core/list/@unroll-any@10031<a,(e :: E)>(xs, predicate);
    });
  };
 fun sum // inline size: 2
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> 0;
      (@pat: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> std/core/list/@lift-sum@10369(xs, 0);
    };
  };
 fun minimum // inline size: 4
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int>, default: (std/core/types/@optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> (match (default) {
          ((std/core/types/@Optional((@uniq-default@4871: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> @uniq-default@4871;
          ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((@skip std/core/types/Cons((x: std/core/types/int) : std/core/types/int, (xx: (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> (match (xx) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@0@0: ((std/core/types/list :: V -> V)<std/core/types/int>))
             -> x;
          (@pat@3: ((std/core/types/list :: V -> V)<std/core/types/int>))
             -> std/core/list/@lift-minimum@10370(xx, x);
        });
    };
  };
 fun maximum // inline size: 4
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/int>, default: (std/core/types/@optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@1: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> (match (default) {
          ((std/core/types/@Optional((@uniq-default@4901: std/core/types/int) : std/core/types/int) : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> @uniq-default@4901;
          ((@skip std/core/types/@None() : (std/core/types/@optional :: V -> V)<std/core/types/int> ) as @pat@0: ((std/core/types/@optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((@skip std/core/types/Cons((x: std/core/types/int) : std/core/types/int, (xx: (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int>) : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/int>))
         -> (match (xx) {
          ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/int> ) as @pat@0@0: ((std/core/types/list :: V -> V)<std/core/types/int>))
             -> x;
          (@pat@3: ((std/core/types/list :: V -> V)<std/core/types/int>))
             -> std/core/list/@lift-maximum@10371(xx, x);
        });
    };
  };
 fun lines // inline size: 2
  = fn(s: std/core/types/string){
    val v@10019[1,0,1,0] : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/string/splitv(s, "\x0A");
    std/core/vector/vlist<std/core/types/string>(v@10019, (std/core/types/@None<(std/core/types/list :: V -> V)<std/core/types/string>>));
  };
 fun unlines // inline size: 7
  = fn(xs: (std/core/types/list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> "";
      ((@skip std/core/types/Cons((x: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@1: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@0: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> x;
      ((std/core/types/Cons((x@0: std/core/types/string) : std/core/types/string, ((std/core/types/Cons((y: std/core/types/string) : std/core/types/string, ((std/core/types/Nil() : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@4: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@3: (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string>) : (std/core/types/list :: V -> V)<std/core/types/string> ) as @pat@2: ((std/core/types/list :: V -> V)<std/core/types/string>))
         | std/core/string/(==)("\x0A", "") -> std/core/types/(++)(x@0, y);
      (@pat@5: ((std/core/types/list :: V -> V)<std/core/types/string>))
         -> std/core/string/#vectorsep/join((std/core/vector/unvlist<std/core/types/string>(xs)), "\x0A");
    };
  };