module interface infer
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import value = value = "";
import expr = expr = "";
import types = types = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
local alias expr/uid[15,1,15,22] = std/core/types/string = 1;
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
local alias std/core/pure[52,1,52,26] :: E = <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> = 1;
local alias types/subst[14,1,14,39] = (std/core/types/list :: V -> V)<(std/core/types/string, types/types)> = 1;
 
//------------------------------
//#kki: type declarations
 
pub alias tenv[7,1,7,35] = (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)> = 2;

// Operations:
// ```koka
// fun modify
// fun tv
// ```
pub recursive effect type tenv-ref[21,1,21,19] <(e :: E),a> :: (E, V) -> V {
  pub con @Hnd-tenv-ref[21,1,21,19](@cfc: std/core/types/int, @fun-modify: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<((tenv == 2 (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)>)) -> (tenv == 2 (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)>),(),(tenv-ref :: (E, V) -> V),(e :: E),a>, @fun-tv: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(tenv == 2 (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)>),(tenv-ref :: (E, V) -> V),(e :: E),a>){0,3,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<((tenv == 2 (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)>)) -> (tenv == 2 (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)>),(),(tenv-ref :: (E, V) -> V),(e :: E),a>, (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<(tenv == 2 (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)>),(tenv-ref :: (E, V) -> V),(e :: E),a>) -> (tenv-ref :: (E, V) -> V)<(e :: E),a>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `@cfc` constructor field of the `:tenv-ref` type.
 fun tenv-ref/@cfc[21,1,21,19] : forall<(e :: E),a> (^ @this : (tenv-ref :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-modify` constructor field of the `:tenv-ref` type.
 fun tenv-ref/@fun-modify[22,7,22,33] : forall<(e :: E),a> (^ @this : (tenv-ref :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>;
// Automatically generated. Retrieves the `@fun-tv` constructor field of the `:tenv-ref` type.
 fun tenv-ref/@fun-tv[23,7,23,16] : forall<(e :: E),a> (^ @this : (tenv-ref :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>;
 fun (+->)[9,5,9,9] : (u : expr/uid, t : types/types) -> (std/core/types/list :: V -> V)<(expr/uid, types/types)>;
// runtime tag for the effect `:tenv-ref`
pub val @tag-tenv-ref[21,1,21,19] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(tenv-ref :: (E, V) -> V)>;
// handler for the effect `:tenv-ref`
pub  fun @handle-tenv-ref[21,12,21,19] : forall<a,(e :: E),b> (hnd : (tenv-ref :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `modify` operation out of effect `:tenv-ref`
pub  fun @select-modify[22,7,22,33] : forall<(e :: E),a> (^ hnd : (tenv-ref :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>;
// Call the `fun modify` operation of the effect `:tenv-ref`
pub  fun modify[22,7,22,12] : (f : (tenv) -> tenv) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>> ();
// select `tv` operation out of effect `:tenv-ref`
pub  fun @select-tv[23,7,23,16] : forall<(e :: E),a> (^ hnd : (tenv-ref :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>;
// Call the `fun tv` operation of the effect `:tenv-ref`
pub  fun tv[23,7,23,8] : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>> tenv;
// monadic lift
 fun @mlift-handle-tenv-ref@10067[1,0,1,0] : forall<(h :: H),(e :: E)> (m : (tenv) -> tenv, tenv : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/core/types/list :: V -> V)<(expr/uid, types/types)>>, @y-x10010 : tenv) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
 fun @mlift-handle-tenv-ref@10068[1,0,1,0] : forall<(h :: H),a,(e :: E)> (t : a, @y-x10013 : (std/core/types/list :: V -> V)<(expr/uid, types/types)>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (a, (std/core/types/list :: V -> V)<(expr/uid, types/types)>);
 fun handle-tenv-ref[25,5,25,19] : forall<a,(e :: E)> (f : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) (a, tenv);
// monadic lift
 fun @mlift-tvar@10069[1,0,1,0] : (v : types/types, wild_ : ()) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-tvar@10070[1,0,1,0] : (u : expr/uid, @y-x10019 : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>> types/types;
pub  fun tvar[55,9,55,12] : (u : expr/uid) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// なぞにtypes/applyの型が合わないのでRe
 fun @trmc-apply'[61,5,61,10] : (t : types/types, s : types/subst, @acc : (std/core/types/ctx :: V -> V)<types/types>) -> <(std/core/types/div :: X)> types/types;
// なぞにtypes/applyの型が合わないのでRe
 fun apply'[61,5,61,10] : (t : types/types, s : types/subst) -> <(std/core/types/div :: X)> types/types;
// monadic lift
 fun @mlift-infer@10071'[1,0,1,0] : (t-ret : types/types, subst : types/subst) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10072'[1,0,1,0] : (t-e1 : types/types, t-e2 : types/types, t-ret : types/types) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10073'[1,0,1,0] : (t-e1 : types/types, t-e2 : types/types) -> <(std/core/pure :: E),(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10074'[1,0,1,0] : (e2 : expr/uexpr, t-e1 : types/types) -> <(std/core/pure :: E),(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10075'[1,0,1,0] : (t-a : types/types, t-body : types/types) -> <(std/core/pure :: E),(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10076'[1,0,1,0] : (body : expr/uexpr, t-a : types/types) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10077'[1,0,1,0] : (x : expr/uid, @y-x10030 : (std/core/types/maybe :: V -> V)<types/types>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10078'[1,0,1,0] : (x : expr/uid, @y-x10029 : tenv) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
pub  fun infer'[35,9,35,14] : (e : expr/uexpr) -> <(std/core/pure :: E),(std/core/console/console :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
pub  fun infer[12,9,12,13] : (e : expr/uexpr) -> <(std/core/console/console :: X),(std/core/types/div :: X)> (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,(types/types, tenv)>;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^"  fun tenv-ref/@cfc // inline size: 0
  = forall<(e :: E),a> fn(@this: (tenv-ref :: (E, V) -> V)<(e :: E),a>){
    (match (@this) {
      ((@skip infer/@Hnd-tenv-ref((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (tenv-ref :: (E, V) -> V)<(e :: E),a> ) as @pat: ((tenv-ref :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun tenv-ref/@fun-modify // inline size: 0
  = forall<(e :: E),a> fn(@this: (tenv-ref :: (E, V) -> V)<(e :: E),a>){
    (match (@this) {
      ((@skip infer/@Hnd-tenv-ref((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (tenv-ref :: (E, V) -> V)<(e :: E),a> ) as @pat: ((tenv-ref :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun tenv-ref/@fun-tv // inline size: 0
  = forall<(e :: E),a> fn(@this: (tenv-ref :: (E, V) -> V)<(e :: E),a>){
    (match (@this) {
      ((@skip infer/@Hnd-tenv-ref((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>, (@x: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (tenv-ref :: (E, V) -> V)<(e :: E),a> ) as @pat: ((tenv-ref :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
 fun (+->) // inline size: 2
  = fn(u: expr/uid, t: types/types){
    std/core/types/Cons<(expr/uid, types/types)>((std/core/types/Tuple2<expr/uid,types/types>(u, t)), (std/core/types/Nil<(expr/uid, types/types)>));
  };
inline borrow "^"  fun @select-modify // inline size: 0
  = forall<(e :: E),a> fn(hnd: (tenv-ref :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip infer/@Hnd-tenv-ref((@pat@0: std/core/types/int) : std/core/types/int, (@fun-modify: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>, (@pat@1: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (tenv-ref :: (E, V) -> V)<(e :: E),a> ) as @pat: ((tenv-ref :: (E, V) -> V)<(e :: E),a>))
         -> @fun-modify;
    });
  };
inline  fun modify // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>>(f: (tenv) -> tenv){
    std/core/hnd/@perform1<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(tenv-ref :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(tenv-ref :: (E, V) -> V)>>((std/core/hnd/@evv-at<(tenv-ref :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), infer/@select-modify, f);
  };
inline borrow "^"  fun @select-tv // inline size: 0
  = forall<(e :: E),a> fn(hnd: (tenv-ref :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip infer/@Hnd-tenv-ref((@pat@0: std/core/types/int) : std/core/types/int, (@pat@1: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(tenv) -> tenv,(),(tenv-ref :: (E, V) -> V),(e :: E),a>, (@fun-tv: (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause0 :: (V, (E, V) -> V, E, V) -> V)<tenv,(tenv-ref :: (E, V) -> V),(e :: E),a>) : (tenv-ref :: (E, V) -> V)<(e :: E),a> ) as @pat: ((tenv-ref :: (E, V) -> V)<(e :: E),a>))
         -> @fun-tv;
    });
  };
inline  fun tv // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>>(){
    std/core/hnd/@perform0<tenv,<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>,(tenv-ref :: (E, V) -> V)>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(tenv-ref :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(tenv-ref :: (E, V) -> V)>>((std/core/hnd/@evv-at<(tenv-ref :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(tenv-ref :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), infer/@select-tv);
  };