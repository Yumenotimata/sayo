module interface expr
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/string = std/core/string pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import std/core/either = std/core/either = "";
import std/core/exn = std/core/exn = "";
import value = value = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
local alias std/core/pure[52,1,52,26] :: E = <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> = 1;
 
//------------------------------
//#kki: type declarations
 
pub recursive rec type expr[8,1,13,16] {
  pub con App[9,3,9,5](e1: expr, e2: expr){0,2,8} : (e1 : expr, e2 : expr) -> expr;
  pub con Let[10,3,10,5](x: std/core/types/string, e1: expr, e2: expr){0,3,8} : (x : std/core/types/string, e1 : expr, e2 : expr) -> expr;
  pub con Lam[11,3,11,5](a: std/core/types/string, body: expr){0,2,8} : (a : std/core/types/string, body : expr) -> expr;
  pub con Lit[12,3,12,5](v: value/value){0,1,8} : (v : value/value) -> expr;
  pub con Var[13,3,13,5](x: std/core/types/string){0,1,8} : (x : std/core/types/string) -> expr;
};
pub alias uid[15,1,15,22] = std/core/types/string = 1;
pub recursive rec type uexpr[17,1,22,14] {
  pub con UApp[18,3,18,6](e1: uexpr, e2: uexpr){0,2,8} : (e1 : uexpr, e2 : uexpr) -> uexpr;
  pub con ULet[19,3,19,6](x: (uid == 1 std/core/types/string), e1: uexpr, e2: uexpr){0,3,8} : (x : (uid == 1 std/core/types/string), e1 : uexpr, e2 : uexpr) -> uexpr;
  pub con ULam[20,3,20,6](a: (uid == 1 std/core/types/string), body: uexpr){0,2,8} : (a : (uid == 1 std/core/types/string), body : uexpr) -> uexpr;
  pub con ULit[21,3,21,6](v: value/value){0,1,8} : (v : value/value) -> uexpr;
  pub con UVar[22,3,22,6](x: (uid == 1 std/core/types/string)){0,1,8} : (x : (uid == 1 std/core/types/string)) -> uexpr;
};

// Operations:
// ```koka
// fun gen
// ```
recursive effect type unique[34,1,34,13] <(e :: E),a> :: (E, V) -> V {
  con @Hnd-unique[34,1,34,13](@cfc: std/core/types/int, @fun-gen: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(uid == 1 std/core/types/string),(unique :: (E, V) -> V),(e :: E),a>){0,2,8} : forall<(e :: E),a> (std/core/types/int, (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,(uid == 1 std/core/types/string),(unique :: (E, V) -> V),(e :: E),a>) -> (unique :: (E, V) -> V)<(e :: E),a>;
};
pub alias usubst[32,1,32,38] = (std/core/types/list :: V -> V)<(std/core/types/string, (uid == 1 std/core/types/string))> = 2;
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Tests for the `App` constructor of the `:expr` type.
pub fip fun is-app[9,3,9,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Let` constructor of the `:expr` type.
pub fip fun is-let[10,3,10,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Lam` constructor of the `:expr` type.
pub fip fun is-lam[11,3,11,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Lit` constructor of the `:expr` type.
pub fip fun is-lit[12,3,12,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `Var` constructor of the `:expr` type.
pub fip fun is-var[13,3,13,5] : (^ expr : expr) -> std/core/types/bool;
// Automatically generated. Tests for the `UApp` constructor of the `:uexpr` type.
pub fip fun is-uapp[18,3,18,6] : (^ uexpr : uexpr) -> std/core/types/bool;
// Automatically generated. Tests for the `ULet` constructor of the `:uexpr` type.
pub fip fun is-ulet[19,3,19,6] : (^ uexpr : uexpr) -> std/core/types/bool;
// Automatically generated. Tests for the `ULam` constructor of the `:uexpr` type.
pub fip fun is-ulam[20,3,20,6] : (^ uexpr : uexpr) -> std/core/types/bool;
// Automatically generated. Tests for the `ULit` constructor of the `:uexpr` type.
pub fip fun is-ulit[21,3,21,6] : (^ uexpr : uexpr) -> std/core/types/bool;
// Automatically generated. Tests for the `UVar` constructor of the `:uexpr` type.
pub fip fun is-uvar[22,3,22,6] : (^ uexpr : uexpr) -> std/core/types/bool;
// Automatically generated. Retrieves the `@cfc` constructor field of the `:unique` type.
 fun unique/@cfc[34,1,34,13] : forall<(e :: E),a> (^ unique : (unique :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int;
// Automatically generated. Retrieves the `@fun-gen` constructor field of the `:unique` type.
 fun unique/@fun-gen[35,7,35,25] : forall<(e :: E),a> (^ unique : (unique :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>;
pub  fun show[24,9,24,12] : (e : uexpr) -> <(std/core/types/div :: X)> std/core/types/string;
// runtime tag for the effect `:unique`
val @tag-unique[34,1,34,13] : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(unique :: (E, V) -> V)>;
// handler for the effect `:unique`
 fun @handle-unique[34,8,34,13] : forall<a,(e :: E),b> (hnd : (unique :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>|(e :: E)> a) -> (e :: E) b;
// select `gen` operation out of effect `:unique`
 fun @select-gen[35,7,35,25] : forall<(e :: E),a> (^ hnd : (unique :: (E, V) -> V)<(e :: E),a>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>;
// Call the `fun gen` operation of the effect `:unique`
 fun gen[35,7,35,9] : (x : std/core/types/string) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> uid;
// monadic lift
 fun @mlift-trmc-uniquify@10041'[1,0,1,0] : (@acc : (std/core/types/ctx :: V -> V)<uexpr>, e2 : expr, us : usubst, @trmc-x10004 : uexpr) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>,(std/core/types/div :: X)> uexpr;
// monadic lift
 fun @mlift-trmc-uniquify@10042'[1,0,1,0] : (@acc : (std/core/types/ctx :: V -> V)<uexpr>, e2@0 : expr, us' : (std/core/types/list :: V -> V)<(std/core/types/string, uid)>, x' : uid, @trmc-x10007 : uexpr) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>,(std/core/types/div :: X)> uexpr;
// monadic lift
 fun @mlift-trmc-uniquify@10043'[1,0,1,0] : (@acc : (std/core/types/ctx :: V -> V)<uexpr>, e1@0 : expr, e2@0 : expr, us : usubst, x : std/core/types/string, x' : uid) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> uexpr;
// monadic lift
 fun @mlift-trmc-uniquify@10044'[1,0,1,0] : (@acc : (std/core/types/ctx :: V -> V)<uexpr>, a : std/core/types/string, body : expr, us : usubst, a' : uid) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> uexpr;
// monadic lift
 fun @mlift-trmc-uniquify@10045'[1,0,1,0] : (@acc : (std/core/types/ctx :: V -> V)<uexpr>, @y-x10025 : uexpr) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> uexpr;
// monadic lift
 fun @mlift-trmc-uniquify@10046'[1,0,1,0] : (@acc : (std/core/types/ctx :: V -> V)<uexpr>, x@0@0 : std/core/types/string, @y-x10024 : (std/core/types/list :: V -> V)<(std/core/types/string, uid)>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> uexpr;
pub  fun @trmc-uniquify'[45,9,45,17] : (e : expr, us : usubst, @acc : (std/core/types/ctx :: V -> V)<uexpr>) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> uexpr;
pub  fun uniquify'[45,9,45,17] : (e : expr, us : usubst) -> <(std/core/pure :: E),(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> uexpr;
// monadic lift
 fun @mlift-uniquify@10047[1,0,1,0] : (@y-x10030 : (std/core/exn/error :: V -> V)<uexpr>) -> <(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,uexpr>;
pub  fun uniquify[37,9,37,16] : (e : expr) -> <(std/core/types/div :: X)> (std/core/types/either :: (V, V) -> V)<std/core/exn/exception,uexpr>;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^" fip fun is-app // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((expr/App((@pat@0: expr) : expr, (@pat@1: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@2: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-let // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((expr/Let((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: expr) : expr, (@pat@2: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@3: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-lam // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((expr/Lam((@pat@0: std/core/types/string) : std/core/types/string, (@pat@1: expr) : expr) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@2: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-lit // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((expr/Lit((@pat@0: value/value) : value/value) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@1: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-var // inline size: 1
  = fn(expr: expr){
    match (expr) {
      ((expr/Var((@pat@0: std/core/types/string) : std/core/types/string) : expr ) as @pat: expr)
         -> std/core/types/True;
      (@pat@1: expr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-uapp // inline size: 1
  = fn(uexpr: uexpr){
    match (uexpr) {
      ((expr/UApp((@pat@0: uexpr) : uexpr, (@pat@1: uexpr) : uexpr) : uexpr ) as @pat: uexpr)
         -> std/core/types/True;
      (@pat@2: uexpr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-ulet // inline size: 1
  = fn(uexpr: uexpr){
    match (uexpr) {
      ((expr/ULet((@pat@0: uid) : uid, (@pat@1: uexpr) : uexpr, (@pat@2: uexpr) : uexpr) : uexpr ) as @pat: uexpr)
         -> std/core/types/True;
      (@pat@3: uexpr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-ulam // inline size: 1
  = fn(uexpr: uexpr){
    match (uexpr) {
      ((expr/ULam((@pat@0: uid) : uid, (@pat@1: uexpr) : uexpr) : uexpr ) as @pat: uexpr)
         -> std/core/types/True;
      (@pat@2: uexpr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-ulit // inline size: 1
  = fn(uexpr: uexpr){
    match (uexpr) {
      ((expr/ULit((@pat@0: value/value) : value/value) : uexpr ) as @pat: uexpr)
         -> std/core/types/True;
      (@pat@1: uexpr)
         -> std/core/types/False;
    };
  };
inline borrow "^" fip fun is-uvar // inline size: 1
  = fn(uexpr: uexpr){
    match (uexpr) {
      ((expr/UVar((@pat@0: uid) : uid) : uexpr ) as @pat: uexpr)
         -> std/core/types/True;
      (@pat@1: uexpr)
         -> std/core/types/False;
    };
  };
inline borrow "^"  fun unique/@cfc // inline size: 0
  = forall<(e :: E),a> fn(unique: (unique :: (E, V) -> V)<(e :: E),a>){
    (match (unique) {
      ((@skip expr/@Hnd-unique((@x: std/core/types/int) : std/core/types/int, (@pat@0: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>) : (unique :: (E, V) -> V)<(e :: E),a> ) as @pat: ((unique :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun unique/@fun-gen // inline size: 0
  = forall<(e :: E),a> fn(unique: (unique :: (E, V) -> V)<(e :: E),a>){
    (match (unique) {
      ((@skip expr/@Hnd-unique((@pat@0: std/core/types/int) : std/core/types/int, (@x: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>) : (unique :: (E, V) -> V)<(e :: E),a> ) as @pat: ((unique :: (E, V) -> V)<(e :: E),a>))
         -> @x;
    });
  };
inline borrow "^"  fun @select-gen // inline size: 0
  = forall<(e :: E),a> fn(hnd: (unique :: (E, V) -> V)<(e :: E),a>){
    (match (hnd) {
      ((@skip expr/@Hnd-unique((@pat@0: std/core/types/int) : std/core/types/int, (@fun-gen: (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>) : (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<std/core/types/string,uid,(unique :: (E, V) -> V),(e :: E),a>) : (unique :: (E, V) -> V)<(e :: E),a> ) as @pat: ((unique :: (E, V) -> V)<(e :: E),a>))
         -> @fun-gen;
    });
  };
inline  fun gen // inline size: 5
  = fn<<(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>>>(x: std/core/types/string){
    std/core/hnd/@perform1<std/core/types/string,uid,(unique :: (E, V) -> V),<(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>>>((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(unique :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(unique :: (E, V) -> V)>>((std/core/hnd/@evv-at<(unique :: (E, V) -> V)>))((std/core/types/@open<(std/core/types/total :: E),<(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(unique :: (E, V) -> V)>> std/core/types/ssize_t>(std/core/types/@make-ssize_t)(0)))), expr/@select-gen, x);
  };