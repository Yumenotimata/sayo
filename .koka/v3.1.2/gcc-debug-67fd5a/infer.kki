module interface infer
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types pub = "";
import std/core/hnd = std/core/hnd pub = "";
import std/core/exn = std/core/exn pub = "";
import std/core/bool = std/core/bool pub = "";
import std/core/order = std/core/order pub = "";
import std/core/char = std/core/char pub = "";
import std/core/int = std/core/int pub = "";
import std/core/vector = std/core/vector pub = "";
import std/core/sslice = std/core/sslice pub = "";
import std/core/list = std/core/list pub = "";
import std/core/maybe = std/core/maybe pub = "";
import std/core/either = std/core/either pub = "";
import std/core/tuple = std/core/tuple pub = "";
import std/core/show = std/core/show pub = "";
import std/core/debug = std/core/debug pub = "";
import std/core/delayed = std/core/delayed pub = "";
import std/core/console = std/core/console pub = "";
import std/core = std/core = "";
import value = value = "";
import expr = expr = "";
import types = types = "";
import std/core/string = std/core/string = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
local alias expr/uid[15,1,15,22] = std/core/types/string = 1;
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
local alias std/core/pure[52,1,52,26] :: E = <(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/div :: X)> = 1;
local alias types/subst[15,1,15,39] = (std/core/types/list :: V -> V)<(std/core/types/string, types/types)> = 1;
 
//------------------------------
//#kki: type declarations
 
pub alias tenv[8,1,8,35] = (std/core/types/list :: V -> V)<((expr/uid == 1 std/core/types/string), types/types)> = 2;
 
//------------------------------
//#kki: declarations
 
 fun (+->)[10,5,10,9] : (u : expr/uid, t : types/types) -> (std/core/types/list :: V -> V)<(expr/uid, types/types)>;
// monadic lift
 fun @mlift-tvar@10055[1,0,1,0] : forall<(h :: H)> (tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, @y-x10004 : std/core/types/int) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
pub  fun tvar[66,9,66,12] : forall<(h :: H)> (tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
pub  fun tvar'[61,9,61,13] : forall<(h :: H)> (u : expr/uid, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>) -> <(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// なぞにtypes/applyの型が合わないのでRe
 fun @trmc-apply'[120,5,120,10] : (t : types/types, s : types/subst, @acc : (std/core/types/ctx :: V -> V)<types/types>) -> <(std/core/console/console :: X),(std/core/types/div :: X)> types/types;
// なぞにtypes/applyの型が合わないのでRe
 fun apply'[120,5,120,10] : (t : types/types, s : types/subst) -> <(std/core/console/console :: X),(std/core/types/div :: X)> types/types;
// monadic lift
 fun @mlift-infer@10056'[1,0,1,0] : forall<(h :: H)> (t-ret : types/types, subst : types/subst) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10057'[1,0,1,0] : forall<(h :: H)> (t-e1 : types/types, t-e2 : types/types, t-ret : types/types) -> <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10058'[1,0,1,0] : forall<(h :: H)> (t-e1 : types/types, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, t-e2 : types/types) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10059'[1,0,1,0] : forall<(h :: H)> (e2 : expr/uexpr, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, t-e1 : types/types) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10060'[1,0,1,0] : forall<(h :: H)> (t-a : types/types, t-body : types/types) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10061'[1,0,1,0] : forall<(h :: H)> (body : expr/uexpr, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, t-a : types/types) -> <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10062'[1,0,1,0] : forall<(h :: H)> (tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, x : expr/uid, @y-x10011 : (std/core/types/maybe :: V -> V)<types/types>) -> <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10063'[1,0,1,0] : forall<(h :: H)> (tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, t-e2@0 : types/types) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10064'[1,0,1,0] : forall<(h :: H)> (e2@0 : expr/uexpr, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, @y-x10017 : (std/core/types/list :: V -> V)<(expr/uid, types/types)>) -> <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>> types/types;
// monadic lift
 fun @mlift-infer@10065'[1,0,1,0] : forall<(h :: H)> (e2@0 : expr/uexpr, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, subst@0 : types/subst) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10066'[1,0,1,0] : forall<(h :: H)> (e2@0 : expr/uexpr, t-x : types/types, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, t-e1@0 : types/types) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10067'[1,0,1,0] : forall<(h :: H)> (e1@0 : expr/uexpr, e2@0 : expr/uexpr, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>, t-x : types/types) -> <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>> types/types;
pub  fun infer'[27,9,27,14] : forall<(h :: H)> (e : expr/uexpr, tv : (std/core/types/ref :: (H, V) -> V)<(h :: H),tenv>) -> <(std/core/pure :: E),(std/core/console/console :: X),(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/handled :: ((E, V) -> V) -> X)<(expr/unique :: (E, V) -> V)>,(std/core/types/write :: H -> X)<(h :: H)>> types/types;
// monadic lift
 fun @mlift-infer@10068[1,0,1,0] : forall<(__h :: H)> (tv : forall<(h1 :: H)> (std/core/types/ref :: (H, V) -> V)<(h1 :: H),tenv>, wild_ : types/types) -> <(std/core/console/console :: X),(std/core/types/div :: X),(std/core/types/handled :: ((E, V) -> V) -> X)<(std/core/exn/exn :: (E, V) -> V)>,(std/core/types/read :: H -> X)<(__h :: H)>,(std/core/types/alloc :: H -> X)<(__h :: H)>,(std/core/types/write :: H -> X)<(__h :: H)>> tenv;
// とりあえずinferで得たいのは型が不明なuidに対する型代入
// 判明しているものは別で得られるとうれしい
pub  fun infer[15,9,15,13] : (e : expr/uexpr) -> <(std/core/pure :: E),(std/core/console/console :: X)> tenv;
 
//------------------------------
//#kki: external declarations
 
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
 fun (+->) // inline size: 2
  = fn(u: expr/uid, t: types/types){
    std/core/types/Cons<(expr/uid, types/types)>((std/core/types/Tuple2<expr/uid,types/types>(u, t)), (std/core/types/Nil<(expr/uid, types/types)>));
  };